{
  "version": 3,
  "sources": ["../node_modules/events/events.js", "../src/subscription.ts", "../src/types.ts", "../src/utils.ts", "../src/transport_sockjs.ts", "../src/transport_websocket.ts", "../src/transport_http_stream.ts", "../src/transport_sse.ts", "../src/transport_webtransport.ts", "../src/json.ts", "../src/centrifuge.ts", "../src/browser.ts"],
  "sourcesContent": ["// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function errorListener(err) {\n      emitter.removeListener(name, resolver);\n      reject(err);\n    }\n\n    function resolver() {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    };\n\n    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });\n    if (name !== 'error') {\n      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });\n    }\n  });\n}\n\nfunction addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n  if (typeof emitter.on === 'function') {\n    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n  }\n}\n\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    // EventTarget does not have `error` event semantics like Node\n    // EventEmitters, we do not listen for `error` events here.\n    emitter.addEventListener(name, function wrapListener(arg) {\n      // IE does not have builtin `{ once: true }` support so we\n      // have to do it manually.\n      if (flags.once) {\n        emitter.removeEventListener(name, wrapListener);\n      }\n      listener(arg);\n    });\n  } else {\n    throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n  }\n}\n", "import EventEmitter from 'events';\nimport { Centrifuge, UnauthorizedError } from './centrifuge';\nimport { errorCodes, unsubscribedCodes, subscribingCodes, connectingCodes } from './codes';\nimport {\n  HistoryOptions, HistoryResult, PresenceResult, PresenceStatsResult,\n  PublishResult, State, SubscriptionEvents, SubscriptionOptions,\n  SubscriptionState, SubscriptionTokenContext, TypedEventEmitter,\n  SubscriptionDataContext\n} from './types';\nimport { ttlMilliseconds, backoff } from './utils';\n\n/** Subscription to a channel */\nexport class Subscription extends (EventEmitter as new () => TypedEventEmitter<SubscriptionEvents>) {\n  channel: string;\n  state: SubscriptionState;\n\n  private _centrifuge: Centrifuge;\n  private _promises: Record<number, any>;\n  private _resubscribeTimeout?: null | ReturnType<typeof setTimeout> = null;\n  private _refreshTimeout?: null | ReturnType<typeof setTimeout> = null;\n  private _getToken: null | ((ctx: SubscriptionTokenContext) => Promise<string>);\n  private _minResubscribeDelay: number;\n  private _maxResubscribeDelay: number;\n  private _recover: boolean;\n  private _offset: number | null;\n  private _epoch: string | null;\n  private _resubscribeAttempts: number;\n  private _promiseId: number;\n\n  private _token: string;\n  private _data: any | null;\n  private _getData: null | ((ctx: SubscriptionDataContext) => Promise<any>);\n  private _recoverable: boolean;\n  private _positioned: boolean;\n  private _joinLeave: boolean;\n  // @ts-ignore \u2013 this is used by a client in centrifuge.ts.\n  private _inflight: boolean;\n\n  /** Subscription constructor should not be used directly, create subscriptions using Client method. */\n  constructor(centrifuge: Centrifuge, channel: string, options?: Partial<SubscriptionOptions>) {\n    super();\n    this.channel = channel;\n    this.state = SubscriptionState.Unsubscribed;\n    this._centrifuge = centrifuge;\n    this._token = '';\n    this._getToken = null;\n    this._data = null;\n    this._getData = null;\n    this._recover = false;\n    this._offset = null;\n    this._epoch = null;\n    this._recoverable = false;\n    this._positioned = false;\n    this._joinLeave = false;\n    this._minResubscribeDelay = 500;\n    this._maxResubscribeDelay = 20000;\n    this._resubscribeTimeout = null;\n    this._resubscribeAttempts = 0;\n    this._promises = {};\n    this._promiseId = 0;\n    this._inflight = false;\n    this._refreshTimeout = null;\n    this._setOptions(options);\n    // @ts-ignore \u2013 we are hiding some symbols from public API autocompletion.\n    if (this._centrifuge._debugEnabled) {\n      this.on('state', (ctx) => {\n        // @ts-ignore \u2013 we are hiding some symbols from public API autocompletion.\n        this._centrifuge._debug('subscription state', channel, ctx.oldState, '->', ctx.newState);\n      });\n      this.on('error', (ctx) => {\n        // @ts-ignore \u2013 we are hiding some symbols from public API autocompletion.\n        this._centrifuge._debug('subscription error', channel, ctx);\n      });\n    } else {\n      // Avoid unhandled exception in EventEmitter for non-set error handler.\n      this.on('error', function () { Function.prototype(); });\n    }\n  }\n\n  /** ready returns a Promise which resolves upon subscription goes to Subscribed \n   * state and rejects in case of subscription goes to Unsubscribed state. \n   * Optional timeout can be passed.*/\n  ready(timeout?: number): Promise<void> {\n    if (this.state === SubscriptionState.Unsubscribed) {\n      return Promise.reject({ code: errorCodes.subscriptionUnsubscribed, message: this.state });\n    }\n    if (this.state === SubscriptionState.Subscribed) {\n      return Promise.resolve();\n    }\n    return new Promise((res, rej) => {\n      const ctx: any = {\n        resolve: res,\n        reject: rej\n      };\n      if (timeout) {\n        ctx.timeout = setTimeout(function () {\n          rej({ code: errorCodes.timeout, message: 'timeout' });\n        }, timeout);\n      }\n      this._promises[this._nextPromiseId()] = ctx;\n    });\n  }\n\n  /** subscribe to a channel.*/\n  subscribe() {\n    if (this._isSubscribed()) {\n      return;\n    }\n    this._resubscribeAttempts = 0;\n    this._setSubscribing(subscribingCodes.subscribeCalled, 'subscribe called');\n  }\n\n  /** unsubscribe from a channel, keeping position state.*/\n  unsubscribe() {\n    this._setUnsubscribed(unsubscribedCodes.unsubscribeCalled, 'unsubscribe called', true);\n  }\n\n  /** publish data to a channel.*/\n  publish(data: any): Promise<PublishResult> {\n    const self = this;\n    return this._methodCall().then(function () {\n      return self._centrifuge.publish(self.channel, data);\n    });\n  }\n\n  /** get online presence for a channel.*/\n  presence(): Promise<PresenceResult> {\n    const self = this;\n    return this._methodCall().then(function () {\n      return self._centrifuge.presence(self.channel);\n    });\n  }\n\n  /** presence stats for a channel (num clients and unique users).*/\n  presenceStats(): Promise<PresenceStatsResult> {\n    const self = this;\n    return this._methodCall().then(function () {\n      return self._centrifuge.presenceStats(self.channel);\n    });\n  }\n\n  /** history for a channel. By default it does not return publications (only current\n   *  StreamPosition data) \u2013 provide an explicit limit > 0 to load publications.*/\n  history(opts: HistoryOptions): Promise<HistoryResult> {\n    const self = this;\n    return this._methodCall().then(function () {\n      return self._centrifuge.history(self.channel, opts);\n    });\n  }\n\n  private _methodCall(): any {\n    if (this._isSubscribed()) {\n      return Promise.resolve();\n    }\n    if (this._isUnsubscribed()) {\n      return Promise.reject({ code: errorCodes.subscriptionUnsubscribed, message: this.state });\n    }\n    return new Promise((res, rej) => {\n      const timeout = setTimeout(function () {\n        rej({ code: errorCodes.timeout, message: 'timeout' });\n        // @ts-ignore \u2013 we are hiding some symbols from public API autocompletion.\n      }, this._centrifuge._config.timeout);\n      this._promises[this._nextPromiseId()] = {\n        timeout: timeout,\n        resolve: res,\n        reject: rej\n      };\n    });\n  }\n\n  private _nextPromiseId() {\n    return ++this._promiseId;\n  }\n\n  private _needRecover() {\n    return this._recover === true;\n  }\n\n  private _isUnsubscribed() {\n    return this.state === SubscriptionState.Unsubscribed;\n  }\n\n  private _isSubscribing() {\n    return this.state === SubscriptionState.Subscribing;\n  }\n\n  private _isSubscribed() {\n    return this.state === SubscriptionState.Subscribed;\n  }\n\n  private _setState(newState: SubscriptionState) {\n    if (this.state !== newState) {\n      const oldState = this.state;\n      this.state = newState;\n      this.emit('state', { newState, oldState, channel: this.channel });\n      return true;\n    }\n    return false;\n  }\n\n  private _usesToken() {\n    return this._token !== '' || this._getToken !== null;\n  }\n\n  private _clearSubscribingState() {\n    this._resubscribeAttempts = 0;\n    this._clearResubscribeTimeout();\n  }\n\n  private _clearSubscribedState() {\n    this._clearRefreshTimeout();\n  }\n\n  private _setSubscribed(result: any) {\n    if (!this._isSubscribing()) {\n      return;\n    }\n    this._clearSubscribingState();\n\n    if (result.recoverable) {\n      this._recover = true;\n      this._offset = result.offset || 0;\n      this._epoch = result.epoch || '';\n    }\n\n    this._setState(SubscriptionState.Subscribed);\n    // @ts-ignore \u2013 we are hiding some methods from public API autocompletion.\n    const ctx = this._centrifuge._getSubscribeContext(this.channel, result);\n    this.emit('subscribed', ctx);\n    this._resolvePromises();\n\n    const pubs = result.publications;\n    if (pubs && pubs.length > 0) {\n      for (const i in pubs) {\n        if (!pubs.hasOwnProperty(i)) {\n          continue;\n        }\n        this._handlePublication(pubs[i]);\n      }\n    }\n\n    if (result.expires === true) {\n      this._refreshTimeout = setTimeout(() => this._refresh(), ttlMilliseconds(result.ttl));\n    }\n  }\n\n  private _setSubscribing(code: number, reason: string) {\n    if (this._isSubscribing()) {\n      return;\n    }\n    if (this._isSubscribed()) {\n      this._clearSubscribedState();\n    }\n    if (this._setState(SubscriptionState.Subscribing)) {\n      this.emit('subscribing', { channel: this.channel, code: code, reason: reason });\n    }\n    this._subscribe(false, false);\n  }\n\n  private _subscribe(optimistic: boolean, skipSending: boolean): any {\n    // @ts-ignore \u2013 we are hiding some symbols from public API autocompletion.\n    this._centrifuge._debug('subscribing on', this.channel);\n\n    if (this._centrifuge.state !== State.Connected && !optimistic) {\n      // @ts-ignore \u2013 we are hiding some symbols from public API autocompletion.\n      this._centrifuge._debug('delay subscribe on', this.channel, 'till connected');\n      // subscribe will be called later automatically.\n      return null;\n    }\n\n    const self = this;\n    const getDataCtx = {\n      channel: self.channel\n    };\n\n    if (!this._usesToken() || this._token) {\n      if (self._getData) {\n        self._getData(getDataCtx).then(function (data: any) {\n          if (!self._isSubscribing()) {\n            return;\n          }\n          self._data = data;\n          self._sendSubscribe(self._token, false);\n        })\n        return null;\n      } else {\n        return self._sendSubscribe(self._token, skipSending);\n      }\n    }\n    if (optimistic) {\n      return null;\n    }\n    this._getSubscriptionToken().then(function (token) {\n      if (!self._isSubscribing()) {\n        return;\n      }\n      if (!token) {\n        self._failUnauthorized();\n        return;\n      }\n      self._token = token;\n      if (self._getData) {\n        self._getData(getDataCtx).then(function (data: any) {\n          if (!self._isSubscribing()) {\n            return;\n          }\n          self._data = data;\n          self._sendSubscribe(token, false);\n        })\n      } else {\n        self._sendSubscribe(token, false);\n      }\n    }).catch(function (e) {\n      if (!self._isSubscribing()) {\n        return;\n      }\n      if (e instanceof UnauthorizedError) {\n        self._failUnauthorized();\n        return;\n      }\n      self.emit('error', {\n        type: 'subscribeToken',\n        channel: self.channel,\n        error: {\n          code: errorCodes.subscriptionSubscribeToken,\n          message: e !== undefined ? e.toString() : ''\n        }\n      });\n      self._scheduleResubscribe();\n    });\n    return null;\n  }\n\n  private _sendSubscribe(token: string, skipSending: boolean): any {\n    const channel = this.channel;\n\n    const req: any = {\n      channel: channel\n    };\n\n    if (token) {\n      req.token = token;\n    }\n\n    if (this._data) {\n      req.data = this._data;\n    }\n\n    if (this._positioned) {\n      req.positioned = true;\n    }\n\n    if (this._recoverable) {\n      req.recoverable = true;\n    }\n\n    if (this._joinLeave) {\n      req.join_leave = true;\n    }\n\n    if (this._needRecover()) {\n      req.recover = true;\n      const offset = this._getOffset();\n      if (offset) {\n        req.offset = offset;\n      }\n      const epoch = this._getEpoch();\n      if (epoch) {\n        req.epoch = epoch;\n      }\n    }\n\n    const cmd = { subscribe: req };\n\n    this._inflight = true;\n\n    // @ts-ignore \u2013 we are hiding some symbols from public API autocompletion.\n    this._centrifuge._call(cmd, skipSending).then(resolveCtx => {\n      this._inflight = false;\n      // @ts-ignore - improve later.\n      const result = resolveCtx.reply.subscribe;\n      this._handleSubscribeResponse(\n        result\n      );\n      // @ts-ignore - improve later.\n      if (resolveCtx.next) {\n        // @ts-ignore - improve later.\n        resolveCtx.next();\n      }\n    }, rejectCtx => {\n      this._inflight = false;\n      this._handleSubscribeError(rejectCtx.error);\n      if (rejectCtx.next) {\n        rejectCtx.next();\n      }\n    });\n    return cmd;\n  }\n\n  private _handleSubscribeError(error) {\n    if (!this._isSubscribing()) {\n      return;\n    }\n    if (error.code === errorCodes.timeout) {\n      // @ts-ignore \u2013 we are hiding some symbols from public API autocompletion.\n      this._centrifuge._disconnect(connectingCodes.subscribeTimeout, 'subscribe timeout', true);\n      return;\n    }\n    this._subscribeError(error);\n  }\n\n  private _handleSubscribeResponse(result) {\n    if (!this._isSubscribing()) {\n      return;\n    }\n    this._setSubscribed(result);\n  }\n\n  private _setUnsubscribed(code, reason, sendUnsubscribe) {\n    if (this._isUnsubscribed()) {\n      return;\n    }\n    if (this._isSubscribed()) {\n      if (sendUnsubscribe) {\n        // @ts-ignore \u2013 we are hiding some methods from public API autocompletion.\n        this._centrifuge._unsubscribe(this);\n      }\n      this._clearSubscribedState();\n    }\n    if (this._isSubscribing()) {\n      if (this._inflight && sendUnsubscribe) {\n        // @ts-ignore \u2013 we are hiding some methods from public API autocompletion.\n        this._centrifuge._unsubscribe(this);\n      }\n      this._clearSubscribingState();\n    }\n    if (this._setState(SubscriptionState.Unsubscribed)) {\n      this.emit('unsubscribed', { channel: this.channel, code: code, reason: reason });\n    }\n    this._rejectPromises({ code: errorCodes.subscriptionUnsubscribed, message: this.state });\n  }\n\n  private _handlePublication(pub: any) {\n    // @ts-ignore \u2013 we are hiding some methods from public API autocompletion.\n    const ctx = this._centrifuge._getPublicationContext(this.channel, pub);\n    this.emit('publication', ctx);\n    if (pub.offset) {\n      this._offset = pub.offset;\n    }\n  }\n\n  protected _handleJoin(join: any) {\n    // @ts-ignore \u2013 we are hiding some methods from public API autocompletion.\n    const info = this._centrifuge._getJoinLeaveContext(join.info)\n    this.emit('join', { channel: this.channel, info: info });\n  }\n\n  protected _handleLeave(leave: any) {\n    // @ts-ignore \u2013 we are hiding some methods from public API autocompletion.\n    const info = this._centrifuge._getJoinLeaveContext(leave.info)\n    this.emit('leave', { channel: this.channel, info: info });\n  }\n\n  private _resolvePromises() {\n    for (const id in this._promises) {\n      if (!this._promises.hasOwnProperty(id)) {\n        continue;\n      }\n      if (this._promises[id].timeout) {\n        clearTimeout(this._promises[id].timeout);\n      }\n      this._promises[id].resolve();\n      delete this._promises[id];\n    }\n  }\n\n  private _rejectPromises(err: any) {\n    for (const id in this._promises) {\n      if (!this._promises.hasOwnProperty(id)) {\n        continue;\n      }\n      if (this._promises[id].timeout) {\n        clearTimeout(this._promises[id].timeout);\n      }\n      this._promises[id].reject(err);\n      delete this._promises[id];\n    }\n  }\n\n  private _scheduleResubscribe() {\n    const self = this;\n    const delay = this._getResubscribeDelay();\n    this._resubscribeTimeout = setTimeout(function () {\n      if (self._isSubscribing()) {\n        self._subscribe(false, false);\n      }\n    }, delay);\n  }\n\n  private _subscribeError(err: any) {\n    if (!this._isSubscribing()) {\n      return;\n    }\n    if (err.code < 100 || err.code === 109 || err.temporary === true) {\n      if (err.code === 109) { // Token expired error.\n        this._token = '';\n      }\n      const errContext = {\n        channel: this.channel,\n        type: 'subscribe',\n        error: err\n      };\n      if (this._centrifuge.state === State.Connected) {\n        this.emit('error', errContext);\n      }\n      this._scheduleResubscribe();\n    } else {\n      this._setUnsubscribed(err.code, err.message, false);\n    }\n  }\n\n  private _getResubscribeDelay() {\n    const delay = backoff(this._resubscribeAttempts, this._minResubscribeDelay, this._maxResubscribeDelay);\n    this._resubscribeAttempts++;\n    return delay;\n  }\n\n  private _setOptions(options: Partial<SubscriptionOptions> | undefined) {\n    if (!options) {\n      return;\n    }\n    if (options.since) {\n      this._offset = options.since.offset;\n      this._epoch = options.since.epoch;\n      this._recover = true;\n    }\n    if (options.data) {\n      this._data = options.data;\n    }\n    if (options.getData) {\n      this._getData = options.getData;\n    }\n    if (options.minResubscribeDelay !== undefined) {\n      this._minResubscribeDelay = options.minResubscribeDelay;\n    }\n    if (options.maxResubscribeDelay !== undefined) {\n      this._maxResubscribeDelay = options.maxResubscribeDelay;\n    }\n    if (options.token) {\n      this._token = options.token;\n    }\n    if (options.getToken) {\n      this._getToken = options.getToken;\n    }\n    if (options.positioned === true) {\n      this._positioned = true;\n    }\n    if (options.recoverable === true) {\n      this._recoverable = true;\n    }\n    if (options.joinLeave === true) {\n      this._joinLeave = true;\n    }\n  }\n\n  private _getOffset() {\n    const offset = this._offset;\n    if (offset !== null) {\n      return offset;\n    }\n    return 0;\n  }\n\n  private _getEpoch() {\n    const epoch = this._epoch;\n    if (epoch !== null) {\n      return epoch;\n    }\n    return '';\n  }\n\n  private _clearRefreshTimeout() {\n    if (this._refreshTimeout !== null) {\n      clearTimeout(this._refreshTimeout);\n      this._refreshTimeout = null;\n    }\n  }\n\n  private _clearResubscribeTimeout() {\n    if (this._resubscribeTimeout !== null) {\n      clearTimeout(this._resubscribeTimeout);\n      this._resubscribeTimeout = null;\n    }\n  }\n\n  private _getSubscriptionToken() {\n    // @ts-ignore \u2013 we are hiding some methods from public API autocompletion.\n    this._centrifuge._debug('get subscription token for channel', this.channel);\n    const ctx = {\n      channel: this.channel\n    };\n    const getToken = this._getToken;\n    if (getToken === null) {\n      this.emit('error', {\n        type: 'configuration',\n        channel: this.channel,\n        error: {\n          code: errorCodes.badConfiguration,\n          message: 'provide a function to get channel subscription token'\n        }\n      });\n      throw new UnauthorizedError('');\n    }\n    return getToken(ctx);\n  }\n\n  private _refresh() {\n    this._clearRefreshTimeout();\n    const self = this;\n    this._getSubscriptionToken().then(function (token) {\n      if (!self._isSubscribed()) {\n        return;\n      }\n      if (!token) {\n        self._failUnauthorized();\n        return;\n      }\n      self._token = token;\n      const req = {\n        channel: self.channel,\n        token: token\n      };\n      const msg = {\n        'sub_refresh': req\n      };\n      // @ts-ignore \u2013 we are hiding some symbols from public API autocompletion.\n      self._centrifuge._call(msg).then(resolveCtx => {\n        // @ts-ignore - improve later.\n        const result = resolveCtx.reply.sub_refresh;\n        self._refreshResponse(result);\n        // @ts-ignore - improve later.\n        if (resolveCtx.next) {\n          // @ts-ignore - improve later.\n          resolveCtx.next();\n        }\n      }, rejectCtx => {\n        self._refreshError(rejectCtx.error);\n        if (rejectCtx.next) {\n          rejectCtx.next();\n        }\n      });\n    }).catch(function (e) {\n      if (e instanceof UnauthorizedError) {\n        self._failUnauthorized();\n        return;\n      }\n      self.emit('error', {\n        type: 'refreshToken',\n        channel: self.channel,\n        error: {\n          code: errorCodes.subscriptionRefreshToken,\n          message: e !== undefined ? e.toString() : ''\n        }\n      });\n      self._refreshTimeout = setTimeout(() => self._refresh(), self._getRefreshRetryDelay());\n    });\n  }\n\n  private _refreshResponse(result: any) {\n    if (!this._isSubscribed()) {\n      return;\n    }\n    // @ts-ignore \u2013 we are hiding some methods from public API autocompletion.\n    this._centrifuge._debug('subscription token refreshed, channel', this.channel);\n    this._clearRefreshTimeout();\n    if (result.expires === true) {\n      this._refreshTimeout = setTimeout(() => this._refresh(), ttlMilliseconds(result.ttl));\n    }\n  }\n\n  private _refreshError(err: any) {\n    if (!this._isSubscribed()) {\n      return;\n    }\n    if (err.code < 100 || err.temporary === true) {\n      this.emit('error', {\n        type: 'refresh',\n        channel: this.channel,\n        error: err\n      });\n      this._refreshTimeout = setTimeout(() => this._refresh(), this._getRefreshRetryDelay());\n    } else {\n      this._setUnsubscribed(err.code, err.message, true);\n    }\n  }\n\n  private _getRefreshRetryDelay() {\n    return backoff(0, 10000, 20000);\n  }\n\n  private _failUnauthorized() {\n    this._setUnsubscribed(unsubscribedCodes.unauthorized, 'unauthorized', true);\n  }\n}\n", "/** EventMap */\nexport type EventMap = {\n  [key: string]: (...args: any[]) => void\n}\n\n/** Typed event emitter. */\nexport interface TypedEventEmitter<Events extends EventMap> {\n  addListener<E extends keyof Events>(event: E, listener: Events[E]): this\n  on<E extends keyof Events>(event: E, listener: Events[E]): this\n  once<E extends keyof Events>(event: E, listener: Events[E]): this\n  prependListener<E extends keyof Events>(event: E, listener: Events[E]): this\n  prependOnceListener<E extends keyof Events>(event: E, listener: Events[E]): this\n  off<E extends keyof Events>(event: E, listener: Events[E]): this\n  removeAllListeners<E extends keyof Events>(event?: E): this\n  removeListener<E extends keyof Events>(event: E, listener: Events[E]): this\n  emit<E extends keyof Events>(event: E, ...args: Parameters<Events[E]>): boolean\n  rawListeners<E extends keyof Events>(event: E): Events[E][]\n  listeners<E extends keyof Events>(event: E): Events[E][]\n}\n\n/** Client events which can be emitted. */\nexport type ClientEvents = {\n  /** called when client state changes */\n  state: (ctx: StateContext) => void;\n  /** called when client goes to connecting state */\n  connecting: (ctx: ConnectingContext) => void;\n  /** called when client goes to connected state */\n  connected: (ctx: ConnectedContext) => void;\n  /** called when client goes to disconnected state */\n  disconnected: (ctx: DisconnectedContext) => void;\n\n  // Async message coming from a server.\n  message: (ctx: MessageContext) => void;\n  // Listen to errors happening internally. \n  error: (ctx: ErrorContext) => void;\n\n  // Listen for server-side subscription events.\n  subscribed: (ctx: ServerSubscribedContext) => void;\n  subscribing: (ctx: ServerSubscribingContext) => void;\n  unsubscribed: (ctx: ServerUnsubscribedContext) => void;\n  publication: (ctx: ServerPublicationContext) => void;\n  join: (ctx: ServerJoinContext) => void;\n  leave: (ctx: ServerLeaveContext) => void;\n}\n\n/** State of client. */\nexport enum State {\n  Disconnected = \"disconnected\",\n  Connecting = \"connecting\",\n  Connected = \"connected\"\n}\n\n/** Events of Subscription. */\nexport type SubscriptionEvents = {\n  /** called when subscription state changes */\n  state: (ctx: SubscriptionStateContext) => void;\n  /** called when subscription state goes to subscribing */\n  subscribing: (ctx: SubscribingContext) => void;\n  /** called when subscription state goes to subscribed */\n  subscribed: (ctx: SubscribedContext) => void;\n  /** called when subscription state goes to unsubscribed */\n  unsubscribed: (ctx: UnsubscribedContext) => void;\n\n  /** called when publication from channel received */\n  publication: (ctx: PublicationContext) => void;\n  /** called when join event from channel received */\n  join: (ctx: JoinContext) => void;\n  /** called when leave event from channel received */\n  leave: (ctx: LeaveContext) => void;\n\n  /** listen to subscription errors happening internally */\n  error: (ctx: SubscriptionErrorContext) => void;\n}\n\n/** State of Subscription */\nexport enum SubscriptionState {\n  Unsubscribed = \"unsubscribed\",\n  Subscribing = \"subscribing\",\n  Subscribed = \"subscribed\"\n}\n\nexport type TransportName = 'websocket' | 'http_stream' | 'sse' | 'sockjs' | 'webtransport';\n\n/** TransportEndpoint allows configuring transport when using fallback mode */\nexport interface TransportEndpoint {\n  /** transport to use */\n  transport: TransportName;\n  /** endpoint for a selected transport type */\n  endpoint: string;\n}\n\n/** Options for Centrifuge client. */\nexport interface Options {\n  /** allows enabling debug mode */\n  debug: boolean;\n  /** allows setting initial connection token (JWT) */\n  token: string;\n  /** allows setting function to get/refresh connection token */\n  getToken: null | ((ctx: ConnectionTokenContext) => Promise<string>);\n  /** data to send to a server with connect command */\n  data: any | null;\n  /** allows setting function to get/renew connection data */\n  getData: null | (() => Promise<any>);\n  /** name of client - it's not a unique name of each connection, it's sth to identify\n   * from where client connected */\n  name: string;\n  /** version of client */\n  version: string;\n  /** minimum delay between reconnect attempts in milliseconds */\n  minReconnectDelay: number;\n  /** maximum delay between reconnect attempts in milliseconds */\n  maxReconnectDelay: number;\n  /** timeout for operations in milliseconds */\n  timeout: number;\n  /** maximum delay of server pings to detect broken connection in milliseconds */\n  maxServerPingDelay: number;\n  /** provide custom WebSocket constructor, useful for NodeJS env where WebSocket is not\n   * available globally */\n  websocket: any | null;\n  /** provide shim for fetch implementation */\n  fetch: any | null;\n  /** provide shim for ReadableStream */\n  readableStream: any | null;\n  /** provide shim for EventSource object */\n  eventsource: any | null;\n  /** provide shim for SockJS object */\n  sockjs: any | null;\n  /** allows modifying options passed to SockJS constructor */\n  sockjsOptions: SockjsOptions;\n  /** which emulation endpoint to use */\n  emulationEndpoint: string;\n  /** EventTarget for network online/offline events, in browser environment \n   * Centrifuge uses global window online/offline events automatically\n   * by default. */\n  networkEventTarget: EventTarget | null;\n}\n\nexport interface SockjsOptions {\n  transports?: string[];\n  timeout?: number;\n}\n\nexport interface StateContext {\n  newState: State;\n  oldState: State;\n}\n\nexport interface ConnectedContext {\n  client: string;\n  transport: string;\n  data?: any;\n}\n\nexport interface ErrorContext {\n  type: string;\n  error: Error;\n  transport?: string;\n}\n\nexport interface Error {\n  code: number;\n  message: string;\n}\n\nexport interface ConnectingContext {\n  code: number;\n  reason: string;\n}\n\nexport interface DisconnectedContext {\n  code: number;\n  reason: string;\n}\n\nexport interface MessageContext {\n  data: any;\n}\n\nexport interface PublicationContext {\n  // channel from which publication was received.\n  channel: string;\n  // data contains publication payload.\n  data: any;\n  // info is an optional ClientInfo object. It's appended to publication only if publication was\n  // sent using client SDK's publish method. If publication was sent over server publish API\n  // this info object is missing as we don't have publisher client context in that case.\n  info?: ClientInfo;\n  // offset may be set for channels where history Centrifugo feature is on. In this case it's an\n  // incremental number assigned to publication by server broker (upon adding to history stream).   \n  offset?: number;\n  // tags is an extra key-value attached to publication, tags may be set when calling server publish API. \n  tags?: Record<string, string>;\n}\n\nexport interface ClientInfo {\n  // client is a globally unique identifier which server allocates for every connection.\n  client: string;\n  // user contains ID of authenticated user. Empty user means anonymous user. One user can have\n  // many client connections.\n  user: string;\n  // connInfo is optional information attached to connection (during connection authentication).\n  connInfo?: any;\n  // chanInfo is optional information attached to subscription (during subscription authorization).\n  chanInfo?: any;\n}\n\nexport interface JoinContext {\n  channel: string;\n  info: ClientInfo;\n}\n\nexport interface LeaveContext {\n  channel: string;\n  info: ClientInfo;\n}\n\nexport interface SubscriptionStateContext {\n  channel: string;\n  newState: SubscriptionState;\n  oldState: SubscriptionState;\n}\n\nexport interface ServerSubscribedContext {\n  /** channel of Subscription. */\n  channel: string;\n  /** Subscription is recoverable \u2013 i.e. can automatically recover missed messages */\n  recoverable: boolean;\n  /** Subscription is positioned \u2013 i.e. server tracks message loss on the way from PUB/SUB broker */\n  positioned: boolean;\n  /** streamPosition set when Subscription is recoverable or positioned. */\n  streamPosition?: StreamPosition;\n  /** wasRecovering is true when recovery was used in subscribe request. */\n  wasRecovering: boolean;\n  /** whether or not missed publications may be successfully recovered.  */\n  recovered: boolean;\n  /** custom data for Subscription returned from server. */\n  data?: any;\n}\n\nexport interface SubscribedContext {\n  channel: string;\n  recoverable: boolean;\n  positioned: boolean;\n  streamPosition?: StreamPosition;\n  wasRecovering: boolean;\n  recovered: boolean;\n  data?: any;\n}\n\nexport interface SubscriptionErrorContext {\n  channel: string;\n  type: string;\n  error: Error;\n}\n\nexport interface UnsubscribedContext {\n  channel: string;\n  code: number;\n  reason: string;\n}\n\nexport interface ServerPublicationContext {\n  // channel from which publication was received.\n  channel: string;\n  // data contains publication payload.\n  data: any;\n  // info is an optional ClientInfo object. It's appended to publication only if publication was\n  // sent using client SDK's publish method. If publication was sent over server publish API\n  // this info object is missing as we don't have publisher client context in that case.\n  info?: ClientInfo;\n  // offset may be set for channels where history Centrifugo feature is on. In this case it's an\n  // incremental number assigned to publication by server broker (upon adding to history stream).   \n  offset?: number;\n  // tags is an extra key-value attached to publication, tags may be set when calling server publish API. \n  tags?: Record<string, string>;\n}\n\nexport interface ServerJoinContext {\n  channel: string;\n  info: ClientInfo;\n}\n\nexport interface ServerLeaveContext {\n  channel: string;\n  info: ClientInfo;\n}\n\nexport interface ServerUnsubscribedContext {\n  channel: string;\n}\n\nexport interface SubscribingContext {\n  channel: string;\n  code: number;\n  reason: string;\n}\n\nexport interface ServerSubscribingContext {\n  channel: string;\n}\n\nexport interface ConnectionTokenContext {\n}\n\nexport interface SubscriptionTokenContext {\n  channel: string;\n}\n\nexport interface SubscriptionDataContext {\n  channel: string;\n}\n\nexport interface PublishResult {\n}\n\nexport interface RpcResult {\n  data: any;\n}\n\nexport interface PresenceResult {\n  clients: Record<string, ClientInfo>;\n}\n\nexport interface PresenceStatsResult {\n  numClients: number;\n  numUsers: number;\n}\n\nexport interface HistoryResult {\n  publications: PublicationContext[];\n  offset: number;\n  epoch: string;\n}\n\nexport interface HistoryOptions {\n  limit?: number;\n  since?: StreamPosition;\n  reverse?: boolean;\n}\n\n/** SubscriptionOptions can customize Subscription. */\nexport interface SubscriptionOptions {\n  /** allows setting initial subscription token (JWT) */\n  token: string;\n  /** allows setting function to get/refresh subscription token */\n  getToken: null | ((ctx: SubscriptionTokenContext) => Promise<string>);\n  /** data to send to a server with subscribe command */\n  data: any | null;\n  /** allows setting function to get/renew subscription data */\n  getData: null | ((ctx: SubscriptionDataContext) => Promise<any>);\n  /** force recovery on first subscribe from a provided StreamPosition. */\n  since: StreamPosition | null;\n  /** min delay between resubscribe attempts. */\n  minResubscribeDelay: number;\n  /** max delay between resubscribe attempts. */\n  maxResubscribeDelay: number;\n  /** ask server to make subscription positioned. */\n  positioned: boolean;\n  /** ask server to make subscription recoverable. */\n  recoverable: boolean;\n  /** ask server to send join/leave messages. */\n  joinLeave: boolean;\n}\n\n/** Stream postion describes position of publication inside a stream.  */\nexport interface StreamPosition {\n  offset: number;\n  epoch: string;\n}\n", "/** @internal */\nexport function startsWith(value, prefix) {\n  return value.lastIndexOf(prefix, 0) === 0;\n}\n\n/** @internal */\nexport function isFunction(value) {\n  if (value === undefined || value === null) {\n    return false;\n  }\n  return typeof value === 'function';\n}\n\n/** @internal */\nexport function log(level: string, args) {\n  if (globalThis.console) {\n    const logger = globalThis.console[level];\n\n    if (isFunction(logger)) {\n      logger.apply(globalThis.console, args);\n    }\n  }\n}\n\nfunction randomInt(min: number, max: number) { // min and max included\n  return Math.floor(Math.random() * (max - min + 1) + min);\n}\n\n/** @internal */\nexport function backoff(step: number, min: number, max: number) {\n  // Full jitter technique, see:\n  // https://aws.amazon.com/blogs/architecture/exponential-backoff-and-jitter/\n  if (step > 31) { step = 31; }\n  const interval = randomInt(0, Math.min(max, min * Math.pow(2, step)));\n  return Math.min(max, min + interval);\n}\n\n/** @internal */\nexport function errorExists(data: any) {\n  return 'error' in data && data.error !== null;\n}\n\n/** @internal */\nexport function ttlMilliseconds(ttl: number) {\n  // https://stackoverflow.com/questions/12633405/what-is-the-maximum-delay-for-setinterval\n  return Math.min(ttl * 1000, 2147483647);\n}\n", "/** @internal */\nexport class SockjsTransport {\n  endpoint: string;\n  options: any;\n  _transport: any;\n\n  constructor(endpoint: string, options: any) {\n    this.endpoint = endpoint;\n    this.options = options;\n    this._transport = null;\n  }\n\n  name() {\n    return 'sockjs';\n  }\n\n  subName() {\n    return 'sockjs-' + this._transport.transport;\n  }\n\n  emulation() {\n    return false;\n  }\n\n  supported() {\n    return this.options.sockjs !== null;\n  }\n\n  initialize(_protocol: 'json', callbacks: any) {\n    this._transport = new this.options.sockjs(this.endpoint, null, this.options.sockjsOptions);\n\n    this._transport.onopen = () => {\n      callbacks.onOpen();\n    };\n\n    this._transport.onerror = e => {\n      callbacks.onError(e);\n    };\n\n    this._transport.onclose = closeEvent => {\n      callbacks.onClose(closeEvent);\n    };\n\n    this._transport.onmessage = event => {\n      callbacks.onMessage(event.data);\n    };\n  }\n\n  close() {\n    this._transport.close();\n  }\n\n  send(data: any) {\n    this._transport.send(data);\n  }\n}\n", "/** @internal */\nexport class WebsocketTransport {\n  private _transport: any;\n  private endpoint: string;\n  private options: any;\n\n  constructor(endpoint: string, options: any) {\n    this.endpoint = endpoint;\n    this.options = options;\n    this._transport = null;\n  }\n\n  name() {\n    return 'websocket';\n  }\n\n  subName() {\n    return 'websocket';\n  }\n\n  emulation() {\n    return false;\n  }\n\n  supported() {\n    return this.options.websocket !== undefined && this.options.websocket !== null;\n  }\n\n  initialize(protocol: string, callbacks: any) {\n    let subProtocol = '';\n    if (protocol === 'protobuf') {\n      subProtocol = 'centrifuge-protobuf';\n    }\n    if (subProtocol !== '') {\n      this._transport = new this.options.websocket(this.endpoint, subProtocol);\n    } else {\n      this._transport = new this.options.websocket(this.endpoint);\n    }\n    if (protocol === 'protobuf') {\n      this._transport.binaryType = 'arraybuffer';\n    }\n\n    this._transport.onopen = () => {\n      callbacks.onOpen();\n    };\n\n    this._transport.onerror = e => {\n      callbacks.onError(e);\n    };\n\n    this._transport.onclose = closeEvent => {\n      callbacks.onClose(closeEvent);\n    };\n\n    this._transport.onmessage = event => {\n      callbacks.onMessage(event.data);\n    };\n  }\n\n  close() {\n    this._transport.close();\n  }\n\n  send(data: any) {\n    this._transport.send(data);\n  }\n}\n", "/** @internal */\nexport class HttpStreamTransport {\n  endpoint: string;\n  options: any;\n  _abortController: any | null;\n  _utf8decoder: TextDecoder;\n  _protocol: string;\n\n  constructor(endpoint, options) {\n    this.endpoint = endpoint;\n    this.options = options;\n    this._abortController = null;\n    this._utf8decoder = new TextDecoder();\n    this._protocol = 'json';\n  }\n\n  name() {\n    return 'http_stream';\n  }\n\n  subName() {\n    return 'http_stream';\n  }\n\n  emulation() {\n    return true;\n  }\n\n  _handleErrors(response: any) {\n    if (!response.ok) throw new Error(response.status);\n    return response;\n  }\n\n  _fetchEventTarget(self, endpoint: string, options: object) {\n    const eventTarget = new EventTarget();\n    // fetch with connection timeout maybe? https://github.com/github/fetch/issues/175\n    const fetchFunc = self.options.fetch;\n    fetchFunc(endpoint, options)\n      .then(self._handleErrors)\n      .then(response => {\n        eventTarget.dispatchEvent(new Event('open'));\n        let jsonStreamBuf = '';\n        let jsonStreamPos = 0;\n        let protoStreamBuf = new Uint8Array();\n        const reader = response.body.getReader();\n        return new self.options.readableStream({\n          start(controller) {\n            function pump() {\n              return reader.read().then(({ done, value }) => {\n                // When no more data needs to be consumed, close the stream\n                if (done) {\n                  eventTarget.dispatchEvent(new Event('close'));\n                  controller.close();\n                  return;\n                }\n                try {\n                  if (self._protocol === 'json') {\n                    jsonStreamBuf += self._utf8decoder.decode(value);\n                    while (jsonStreamPos < jsonStreamBuf.length) {\n                      if (jsonStreamBuf[jsonStreamPos] === '\\n') {\n                        const line = jsonStreamBuf.substring(0, jsonStreamPos);\n                        eventTarget.dispatchEvent(new MessageEvent('message', { data: line }));\n                        jsonStreamBuf = jsonStreamBuf.substring(jsonStreamPos + 1);\n                        jsonStreamPos = 0;\n                      } else {\n                        ++jsonStreamPos;\n                      }\n                    }\n                  } else {\n                    const mergedArray = new Uint8Array(protoStreamBuf.length + value.length);\n                    mergedArray.set(protoStreamBuf);\n                    mergedArray.set(value, protoStreamBuf.length);\n                    protoStreamBuf = mergedArray;\n\n                    while (true) {\n                      const result = self.options.decoder.decodeReply(protoStreamBuf);\n                      if (result.ok) {\n                        const data = protoStreamBuf.slice(0, result.pos);\n                        eventTarget.dispatchEvent(new MessageEvent('message', { data: data }));\n                        protoStreamBuf = protoStreamBuf.slice(result.pos);\n                        continue;\n                      }\n                      break;\n                    }\n                  }\n                } catch (error) {\n                  // @ts-ignore - improve later.\n                  eventTarget.dispatchEvent(new Event('error', { detail: error }));\n                  eventTarget.dispatchEvent(new Event('close'));\n                  controller.close();\n                  return;\n                }\n                pump();\n              }).catch(function (e) {\n                // @ts-ignore - improve later.\n                eventTarget.dispatchEvent(new Event('error', { detail: e }));\n                eventTarget.dispatchEvent(new Event('close'));\n                controller.close();\n                return;\n              });\n            }\n            return pump();\n          }\n        });\n      })\n      .catch(error => {\n        // @ts-ignore - improve later.\n        eventTarget.dispatchEvent(new Event('error', { detail: error }));\n        eventTarget.dispatchEvent(new Event('close'));\n      });\n    return eventTarget;\n  }\n\n  supported() {\n    return this.options.fetch !== null &&\n      this.options.readableStream !== null &&\n      typeof TextDecoder !== 'undefined' &&\n      typeof AbortController !== 'undefined' &&\n      typeof EventTarget !== 'undefined' &&\n      typeof Event !== 'undefined' &&\n      typeof MessageEvent !== 'undefined' &&\n      typeof Error !== 'undefined';\n  }\n\n  initialize(protocol: string, callbacks: any, initialData: any) {\n    this._protocol = protocol;\n    this._abortController = new AbortController();\n    let headers: any;\n    let body: any;\n    if (protocol === 'json') {\n      headers = {\n        'Accept': 'application/json',\n        'Content-Type': 'application/json'\n      };\n      body = initialData;\n    } else {\n      headers = {\n        'Accept': 'application/octet-stream',\n        'Content-Type': 'application/octet-stream'\n      };\n      body = initialData;\n    }\n\n    const fetchOptions = {\n      method: 'POST',\n      headers: headers,\n      body: body,\n      mode: 'cors',\n      credentials: 'same-origin',\n      cache: 'no-cache',\n      signal: this._abortController.signal\n    }\n\n    const eventTarget = this._fetchEventTarget(\n      this,\n      this.endpoint,\n      fetchOptions\n    );\n\n    eventTarget.addEventListener('open', () => {\n      callbacks.onOpen();\n    });\n\n    eventTarget.addEventListener('error', (e) => {\n      this._abortController.abort();\n      callbacks.onError(e);\n    });\n\n    eventTarget.addEventListener('close', () => {\n      this._abortController.abort();\n      callbacks.onClose({\n        code: 4,\n        reason: 'connection closed'\n      });\n    });\n\n    eventTarget.addEventListener('message', (e: any) => {\n      callbacks.onMessage(e.data);\n    });\n  }\n\n  close() {\n    this._abortController.abort();\n  }\n\n  send(data: any, session: string, node: string) {\n    let headers: any;\n    let body: any;\n    const req = {\n      session: session,\n      node: node,\n      data: data\n    };\n    if (this._protocol === 'json') {\n      headers = {\n        'Content-Type': 'application/json'\n      };\n      body = JSON.stringify(req);\n    } else {\n      headers = {\n        'Content-Type': 'application/octet-stream'\n      };\n      body = this.options.encoder.encodeEmulationRequest(req);\n    }\n\n    const fetchFunc = this.options.fetch;\n    const fetchOptions = {\n      method: 'POST',\n      headers: headers,\n      body: body,\n      mode: 'cors',\n      credentials: 'same-origin',\n      cache: 'no-cache'\n    }\n    fetchFunc(this.options.emulationEndpoint, fetchOptions);\n  }\n}\n", "/** @internal */\nexport class SseTransport {\n  endpoint: string;\n  options: any;\n  _protocol: string;\n  _transport: any;\n  _onClose: any;\n\n  constructor(endpoint: string, options: any) {\n    this.endpoint = endpoint;\n    this.options = options;\n    this._protocol = 'json';\n    this._transport = null;\n    this._onClose = null;\n  }\n\n  name() {\n    return 'sse';\n  }\n\n  subName() {\n    return 'sse';\n  }\n\n  emulation() {\n    return true;\n  }\n\n  supported() {\n    return this.options.eventsource !== null && this.options.fetch !== null;\n  }\n\n  initialize(_protocol: 'json', callbacks: any, initialData: any) {\n    let url: any;\n    if (globalThis && globalThis.document && globalThis.document.baseURI) {\n      // Handle case when endpoint is relative, like //example.com/connection/sse\n      url = new URL(this.endpoint, globalThis.document.baseURI);\n    } else {\n      url = new URL(this.endpoint);\n    }\n    url.searchParams.append('cf_connect', initialData);\n\n    const eventsourceOptions = {}\n    const eventSource = new this.options.eventsource(url.toString(), eventsourceOptions);\n    this._transport = eventSource;\n\n    const self = this;\n\n    eventSource.onopen = function () {\n      callbacks.onOpen();\n    };\n\n    eventSource.onerror = function (e) {\n      eventSource.close();\n      callbacks.onError(e);\n      callbacks.onClose({\n        code: 4,\n        reason: 'connection closed'\n      });\n    };\n\n    eventSource.onmessage = function (e) {\n      callbacks.onMessage(e.data);\n    };\n\n    self._onClose = function () {\n      callbacks.onClose({\n        code: 4,\n        reason: 'connection closed'\n      });\n    };\n  }\n\n  close() {\n    this._transport.close();\n    if (this._onClose !== null) {\n      this._onClose();\n    }\n  }\n\n  send(data: any, session: string, node: string) {\n    const req = {\n      session: session,\n      node: node,\n      data: data\n    };\n    const headers = {\n      'Content-Type': 'application/json'\n    };\n    const body = JSON.stringify(req);\n    const fetchFunc = this.options.fetch;\n    const fetchOptions = {\n      method: 'POST',\n      headers: headers,\n      body: body,\n      mode: 'cors',\n      credentials: 'same-origin',\n      cache: 'no-cache'\n    }\n    fetchFunc(this.options.emulationEndpoint, fetchOptions);\n  }\n}\n", "/** @internal */\nexport class WebtransportTransport {\n  private _transport: any;\n  private _stream: any;\n  private _writer: any;\n  private endpoint: string;\n  private options: any;\n  _utf8decoder: TextDecoder;\n  _protocol: string;\n\n  constructor(endpoint: string, options: any) {\n    this.endpoint = endpoint;\n    this.options = options;\n    this._transport = null;\n    this._stream = null;\n    this._writer = null;\n    this._utf8decoder = new TextDecoder();\n    this._protocol = 'json';\n  }\n\n  name() {\n    return 'webtransport';\n  }\n\n  subName() {\n    return 'webtransport';\n  }\n\n  emulation() {\n    return false;\n  }\n\n  supported() {\n    return this.options.webtransport !== undefined && this.options.webtransport !== null;\n  }\n\n  async initialize(protocol: string, callbacks: any) {\n    let url: any;\n    if (globalThis && globalThis.document && globalThis.document.baseURI) {\n      // Handle case when endpoint is relative, like //example.com/connection/webtransport\n      url = new URL(this.endpoint, globalThis.document.baseURI);\n    } else {\n      url = new URL(this.endpoint);\n    }\n    if (protocol === 'protobuf') {\n      url.searchParams.append('cf_protocol', 'protobuf');\n    }\n\n    this._protocol = protocol;\n    const eventTarget = new EventTarget();\n\n    this._transport = new this.options.webtransport(url.toString());\n    this._transport.closed.then(() => {\n      callbacks.onClose({\n        code: 4,\n        reason: 'connection closed'\n      });\n    }).catch(() => {\n      callbacks.onClose({\n        code: 4,\n        reason: 'connection closed'\n      });\n    });\n    try {\n      await this._transport.ready;\n    } catch {\n      this.close();\n      return;\n    }\n    let stream: any;\n    try {\n      stream = await this._transport.createBidirectionalStream();\n    } catch {\n      this.close();\n      return;\n    }\n    this._stream = stream;\n    this._writer = this._stream.writable.getWriter();\n\n    eventTarget.addEventListener('close', () => {\n      callbacks.onClose({\n        code: 4,\n        reason: 'connection closed'\n      });\n    });\n\n    eventTarget.addEventListener('message', (e: any) => {\n      callbacks.onMessage(e.data);\n    });\n\n    this._startReading(eventTarget);\n\n    callbacks.onOpen();\n  }\n\n  async _startReading(eventTarget: any) {\n    const reader = this._stream.readable.getReader();\n    let jsonStreamBuf = '';\n    let jsonStreamPos = 0;\n    let protoStreamBuf = new Uint8Array();\n    try {\n      while (true) {\n        const { done, value } = await reader.read();\n        if (value.length > 0) {\n          if (this._protocol === 'json') {\n            jsonStreamBuf += this._utf8decoder.decode(value);\n            while (jsonStreamPos < jsonStreamBuf.length) {\n              if (jsonStreamBuf[jsonStreamPos] === '\\n') {\n                const line = jsonStreamBuf.substring(0, jsonStreamPos);\n                eventTarget.dispatchEvent(new MessageEvent('message', { data: line }));\n                jsonStreamBuf = jsonStreamBuf.substring(jsonStreamPos + 1);\n                jsonStreamPos = 0;\n              } else {\n                ++jsonStreamPos;\n              }\n            }\n          } else {\n            const mergedArray = new Uint8Array(protoStreamBuf.length + value.length);\n            mergedArray.set(protoStreamBuf);\n            mergedArray.set(value, protoStreamBuf.length);\n            protoStreamBuf = mergedArray;\n\n            while (true) {\n              const result = this.options.decoder.decodeReply(protoStreamBuf);\n              if (result.ok) {\n                const data = protoStreamBuf.slice(0, result.pos);\n                eventTarget.dispatchEvent(new MessageEvent('message', { data: data }));\n                protoStreamBuf = protoStreamBuf.slice(result.pos);\n                continue;\n              }\n              break;\n            }\n          }\n        }\n        if (done) {\n          break;\n        }\n      }\n    } catch {\n      eventTarget.dispatchEvent(new Event('close'));\n    }\n  }\n\n  async close() {\n    try {\n      if (this._writer) {\n        await this._writer.close();\n      }\n      this._transport.close();\n    } catch (e) {\n      // already closed.\n    }\n  }\n\n  async send(data: any) {\n    let binary: Uint8Array;\n    if (this._protocol === 'json') {\n      // Need extra \\n since WT is non-frame protocol. \n      binary = new TextEncoder().encode(data + '\\n');\n    } else {\n      binary = data;\n    }\n    try {\n      await this._writer.write(binary);\n    } catch (e) {\n      this.close();\n    }\n  }\n}\n", "/** @internal */\nexport class JsonCodec {\n  name() {\n    return 'json';\n  }\n\n  encodeCommands(commands: any[]): string {\n    return commands.map(c => JSON.stringify(c)).join('\\n');\n  }\n\n  decodeReplies(data: string): any[] {\n    return data.trim().split('\\n').map(r => JSON.parse(r));\n  }\n}\n", "import { Subscription } from './subscription';\nimport {\n  errorCodes, disconnectedCodes,\n  connectingCodes, subscribingCodes\n} from './codes';\n\nimport { SockjsTransport } from './transport_sockjs';\nimport { WebsocketTransport } from './transport_websocket';\nimport { HttpStreamTransport } from './transport_http_stream';\nimport { SseTransport } from './transport_sse';\nimport { WebtransportTransport } from './transport_webtransport';\n\nimport { JsonCodec } from './json';\n\nimport {\n  isFunction, log, startsWith, errorExists,\n  backoff, ttlMilliseconds\n} from './utils';\n\nimport {\n  State, Options, SubscriptionState, ClientEvents,\n  TypedEventEmitter, RpcResult, SubscriptionOptions,\n  HistoryOptions, HistoryResult, PublishResult,\n  PresenceResult, PresenceStatsResult, SubscribedContext,\n  TransportEndpoint,\n} from './types';\n\nimport EventEmitter from 'events';\n\nconst defaults: Options = {\n  token: '',\n  getToken: null,\n  data: null,\n  getData: null,\n  debug: false,\n  name: 'js',\n  version: '',\n  fetch: null,\n  readableStream: null,\n  websocket: null,\n  eventsource: null,\n  sockjs: null,\n  sockjsOptions: {},\n  emulationEndpoint: '/emulation',\n  minReconnectDelay: 500,\n  maxReconnectDelay: 20000,\n  timeout: 5000,\n  maxServerPingDelay: 10000,\n  networkEventTarget: null,\n}\n\ninterface serverSubscription {\n  offset: number;\n  epoch: string;\n  recoverable: boolean;\n}\n\nexport class UnauthorizedError extends Error {\n  constructor(message: any) {\n    super(message);\n    this.name = this.constructor.name;\n  }\n}\n\n/** Centrifuge is a Centrifuge/Centrifugo bidirectional client. */\nexport class Centrifuge extends (EventEmitter as new () => TypedEventEmitter<ClientEvents>) {\n  state: State;\n  private _endpoint: string | Array<TransportEndpoint>;\n  private _emulation: boolean;\n  private _transports: any[];\n  private _currentTransportIndex: number;\n  private _triedAllTransports: boolean;\n  private _transportWasOpen: boolean;\n  private _transport?: any;\n  private _transportId: number;\n  private _deviceWentOffline: boolean;\n  private _transportClosed: boolean;\n  private _reconnecting: boolean;\n  private _reconnectTimeout?: null | ReturnType<typeof setTimeout> = null;\n  private _reconnectAttempts: number;\n  private _client: null;\n  private _session: string;\n  private _node: string;\n  private _subs: Record<string, Subscription>;\n  private _serverSubs: Record<string, serverSubscription>;\n  private _commandId: number;\n  private _commands: any[];\n  private _batching: boolean;\n  private _refreshRequired: boolean;\n  private _refreshTimeout?: null | ReturnType<typeof setTimeout> = null;\n  private _callbacks: Record<number, any>;\n  private _token: string;\n  private _data: any;\n  private _dispatchPromise: Promise<void>;\n  private _serverPing: number;\n  private _serverPingTimeout?: null | ReturnType<typeof setTimeout> = null;\n  private _sendPong: boolean;\n  private _promises: Record<number, any>;\n  private _promiseId: number;\n  private _networkEventsSet: boolean;\n\n  private _debugEnabled: boolean;\n  private _config: Options;\n  protected _codec: any;\n\n  static SubscriptionState: typeof SubscriptionState;\n  static State: typeof State;\n  static UnauthorizedError: typeof UnauthorizedError;\n\n  /** Constructs Centrifuge client. Call connect() method to start connecting. */\n  constructor(endpoint: string | Array<TransportEndpoint>, options?: Partial<Options>) {\n    super();\n    this.state = State.Disconnected;\n    this._endpoint = endpoint;\n    this._emulation = false;\n    this._transports = [];\n    this._currentTransportIndex = 0;\n    this._triedAllTransports = false;\n    this._transportWasOpen = false;\n    this._transport = null;\n    this._transportId = 0;\n    this._deviceWentOffline = false;\n    this._transportClosed = true;\n    this._codec = new JsonCodec();\n    this._reconnecting = false;\n    this._reconnectTimeout = null;\n    this._reconnectAttempts = 0;\n    this._client = null;\n    this._session = '';\n    this._node = '';\n    this._subs = {};\n    this._serverSubs = {};\n    this._commandId = 0;\n    this._commands = [];\n    this._batching = false;\n    this._refreshRequired = false;\n    this._refreshTimeout = null;\n    this._callbacks = {};\n    this._token = '';\n    this._data = null;\n    this._dispatchPromise = Promise.resolve();\n    this._serverPing = 0;\n    this._serverPingTimeout = null;\n    this._sendPong = false;\n    this._promises = {};\n    this._promiseId = 0;\n    this._debugEnabled = false;\n    this._networkEventsSet = false;\n\n    this._config = { ...defaults, ...options };\n    this._configure();\n\n    if (this._debugEnabled) {\n      this.on('state', (ctx) => {\n        this._debug('client state', ctx.oldState, '->', ctx.newState);\n      });\n      this.on('error', (ctx) => {\n        this._debug('client error', ctx);\n      });\n    } else {\n      // Avoid unhandled exception in EventEmitter for non-set error handler.\n      this.on('error', function () { Function.prototype(); });\n    }\n  }\n\n  /** newSubscription allocates new Subscription to a channel. Since server only allows \n   * one subscription per channel per client this method throws if client already has \n   * channel subscription in internal registry.\n   * */\n  newSubscription(channel: string, options?: Partial<SubscriptionOptions>): Subscription {\n    if (this.getSubscription(channel) !== null) {\n      throw new Error('Subscription to the channel ' + channel + ' already exists');\n    }\n    const sub = new Subscription(this, channel, options);\n    this._subs[channel] = sub;\n    return sub;\n  }\n\n  /** getSubscription returns Subscription if it's registered in the internal \n   * registry or null. */\n  getSubscription(channel: string): Subscription | null {\n    return this._getSub(channel);\n  }\n\n  /** removeSubscription allows removing Subcription from the internal registry. Subscrption \n   * must be in unsubscribed state. */\n  removeSubscription(sub: Subscription | null) {\n    if (!sub) {\n      return;\n    }\n    if (sub.state !== SubscriptionState.Unsubscribed) {\n      sub.unsubscribe();\n    }\n    this._removeSubscription(sub);\n  }\n\n  /** Get a map with all current client-side subscriptions. */\n  subscriptions(): Record<string, Subscription> {\n    return this._subs;\n  }\n\n  /** ready returns a Promise which resolves upon client goes to Connected \n   * state and rejects in case of client goes to Disconnected or Failed state.\n   * Users can provide optional timeout in milliseconds. */\n  ready(timeout?: number): Promise<void> {\n    if (this.state === State.Disconnected) {\n      return Promise.reject({ code: errorCodes.clientDisconnected, message: 'client disconnected' });\n    }\n    if (this.state === State.Connected) {\n      return Promise.resolve();\n    }\n    return new Promise((res, rej) => {\n      const ctx: any = {\n        resolve: res,\n        reject: rej\n      };\n      if (timeout) {\n        ctx.timeout = setTimeout(function () {\n          rej({ code: errorCodes.timeout, message: 'timeout' });\n        }, timeout);\n      }\n      this._promises[this._nextPromiseId()] = ctx;\n    });\n  }\n\n  /** connect to a server. */\n  connect() {\n    if (this._isConnected()) {\n      this._debug('connect called when already connected');\n      return;\n    }\n    if (this._isConnecting()) {\n      this._debug('connect called when already connecting');\n      return;\n    }\n    this._debug('connect called');\n    this._reconnectAttempts = 0;\n    this._startConnecting();\n  }\n\n  /** disconnect from a server. */\n  disconnect() {\n    this._disconnect(disconnectedCodes.disconnectCalled, 'disconnect called', false);\n  }\n\n  /** setToken allows setting connection token. Or resetting used token to be empty.  */\n  setToken(token: string) {\n    this._token = token;\n  }\n\n  /** send asynchronous data to a server (without any response from a server \n   * expected, see rpc method if you need response). */\n  send(data: any): Promise<void> {\n    const cmd = {\n      send: {\n        data: data\n      }\n    };\n\n    const self = this;\n\n    return this._methodCall().then(function () {\n      const sent = self._transportSendCommands([cmd]); // can send message to server without id set\n      if (!sent) {\n        return Promise.reject(self._createErrorObject(errorCodes.transportWriteError, 'transport write error'));\n      }\n      return Promise.resolve();\n    });\n  }\n\n  /** rpc to a server - i.e. a call which waits for a response with data. */\n  rpc(method: string, data: any): Promise<RpcResult> {\n    const cmd = {\n      rpc: {\n        method: method,\n        data: data\n      }\n    };\n\n    const self = this;\n\n    return this._methodCall().then(function () {\n      return self._callPromise(cmd, function (reply: any) {\n        return {\n          'data': reply.rpc.data\n        };\n      });\n    });\n  }\n\n  /** publish data to a channel. */\n  publish(channel: string, data: any): Promise<PublishResult> {\n    const cmd = {\n      publish: {\n        channel: channel,\n        data: data\n      }\n    };\n\n    const self = this;\n\n    return this._methodCall().then(function () {\n      return self._callPromise(cmd, function () {\n        return {};\n      });\n    });\n  }\n\n  /** history for a channel. By default it does not return publications (only current\n   *  StreamPosition data) \u2013 provide an explicit limit > 0 to load publications.*/\n  history(channel: string, options?: HistoryOptions): Promise<HistoryResult> {\n    const cmd = {\n      history: this._getHistoryRequest(channel, options)\n    };\n\n    const self = this;\n\n    return this._methodCall().then(function () {\n      return self._callPromise(cmd, function (reply: any) {\n        const result = reply.history;\n        const publications: any[] = [];\n        if (result.publications) {\n          for (let i = 0; i < result.publications.length; i++) {\n            publications.push(self._getPublicationContext(channel, result.publications[i]));\n          }\n        }\n        return {\n          'publications': publications,\n          'epoch': result.epoch || '',\n          'offset': result.offset || 0\n        };\n      });\n    });\n  }\n\n  /** presence for a channel. */\n  presence(channel: string): Promise<PresenceResult> {\n    const cmd = {\n      presence: {\n        channel: channel\n      }\n    };\n\n    const self = this;\n\n    return this._methodCall().then(function () {\n      return self._callPromise(cmd, function (reply: any) {\n        const clients = reply.presence.presence;\n        for (const clientId in clients) {\n          if (clients.hasOwnProperty(clientId)) {\n            const connInfo = clients[clientId]['conn_info'];\n            const chanInfo = clients[clientId]['chan_info'];\n            if (connInfo) {\n              clients[clientId].connInfo = connInfo;\n            }\n            if (chanInfo) {\n              clients[clientId].chanInfo = chanInfo;\n            }\n          }\n        }\n        return {\n          'clients': clients\n        };\n      });\n    });\n  }\n\n  /** presence stats for a channel. */\n  presenceStats(channel: string): Promise<PresenceStatsResult> {\n    const cmd = {\n      'presence_stats': {\n        channel: channel\n      }\n    };\n\n    const self = this;\n\n    return this._methodCall().then(function () {\n      return self._callPromise(cmd, function (reply: any) {\n        const result = reply.presence_stats;\n        return {\n          'numUsers': result.num_users,\n          'numClients': result.num_clients\n        };\n      });\n    });\n  }\n\n  /** start command batching (collect into temporary buffer without sending to a server) \n   * until stopBatching called.*/\n  startBatching() {\n    // start collecting messages without sending them to Centrifuge until flush\n    // method called\n    this._batching = true;\n  }\n\n  /** stop batching commands and flush collected commands to the \n   * network (all in one request/frame).*/\n  stopBatching() {\n    const self = this;\n    // Why so nested? Two levels here requred to deal with promise resolving queue.\n    // In Subscription case we wait 2 futures before sending data to connection.\n    // Otherwise _batching becomes false before batching decision has a chance to be executed.\n    Promise.resolve().then(function () {\n      Promise.resolve().then(function () {\n        self._batching = false;\n        self._flush();\n      })\n    })\n  }\n\n  private _debug(...args: any[]) {\n    if (!this._debugEnabled) {\n      return;\n    }\n    log('debug', args);\n  }\n\n  /** @internal */\n  protected _formatOverride() {\n    return;\n  }\n\n  private _configure() {\n    if (!('Promise' in globalThis)) {\n      throw new Error('Promise polyfill required');\n    }\n\n    if (!this._endpoint) {\n      throw new Error('endpoint configuration required');\n    }\n\n    if (this._config.token !== null) {\n      this._token = this._config.token;\n    }\n\n    if (this._config.data !== null) {\n      this._data = this._config.data;\n    }\n\n    this._codec = new JsonCodec();\n    this._formatOverride();\n\n    if (this._config.debug === true ||\n      (typeof localStorage !== 'undefined' && localStorage.getItem('centrifuge.debug'))) {\n      this._debugEnabled = true;\n    }\n\n    this._debug('config', this._config);\n\n    if (typeof this._endpoint === 'string') {\n      // Single address.\n    } else if (typeof this._endpoint === 'object' && this._endpoint instanceof Array) {\n      this._transports = this._endpoint;\n      this._emulation = true;\n      for (const i in this._transports) {\n        if (this._transports.hasOwnProperty(i)) {\n          const transportConfig = this._transports[i];\n          if (!transportConfig.endpoint || !transportConfig.transport) {\n            throw new Error('malformed transport configuration');\n          }\n          const transportName = transportConfig.transport;\n          if (['websocket', 'http_stream', 'sse', 'sockjs', 'webtransport'].indexOf(transportName) < 0) {\n            throw new Error('unsupported transport name: ' + transportName);\n          }\n        }\n      }\n    } else {\n      throw new Error('unsupported url configuration type: only string or array of objects are supported');\n    }\n  }\n\n  private _setState(newState: State) {\n    if (this.state !== newState) {\n      this._reconnecting = false;\n      const oldState = this.state;\n      this.state = newState;\n      this.emit('state', { newState, oldState });\n      return true;\n    }\n    return false;\n  }\n\n  private _isDisconnected() {\n    return this.state === State.Disconnected;\n  }\n\n  private _isConnecting() {\n    return this.state === State.Connecting;\n  }\n\n  private _isConnected() {\n    return this.state === State.Connected;\n  }\n\n  private _nextCommandId() {\n    return ++this._commandId;\n  }\n\n  private _setNetworkEvents() {\n    if (this._networkEventsSet) {\n      return;\n    }\n    let eventTarget: EventTarget | null = null;\n    if (this._config.networkEventTarget !== null) {\n      eventTarget = this._config.networkEventTarget;\n    } else if (typeof globalThis.addEventListener !== 'undefined') {\n      eventTarget = globalThis as EventTarget;\n    }\n    if (eventTarget) {\n      eventTarget.addEventListener('offline', () => {\n        this._debug('offline event triggered');\n        if (this.state === State.Connected || this.state === State.Connecting) {\n          this._disconnect(connectingCodes.transportClosed, 'transport closed', true);\n          this._deviceWentOffline = true;\n        }\n      });\n      eventTarget.addEventListener('online', () => {\n        this._debug('online event triggered');\n        if (this.state !== State.Connecting) {\n          return;\n        }\n        if (this._deviceWentOffline && !this._transportClosed) {\n          // This is a workaround for mobile Safari where close callback may be\n          // not issued upon device going to the flight mode. We know for sure\n          // that transport close was called, so we start reconnecting. In this\n          // case if the close callback will be issued for some reason after some\n          // time \u2013 it will be ignored due to transport ID mismatch.\n          this._deviceWentOffline = false;\n          this._transportClosed = true;\n        }\n        this._clearReconnectTimeout();\n        this._startReconnecting();\n      });\n      this._networkEventsSet = true;\n    }\n  }\n\n  private _getReconnectDelay() {\n    const delay = backoff(this._reconnectAttempts, this._config.minReconnectDelay, this._config.maxReconnectDelay);\n    this._reconnectAttempts += 1;\n    return delay;\n  }\n\n  private _clearOutgoingRequests() {\n    // fire errbacks of registered outgoing calls.\n    for (const id in this._callbacks) {\n      if (this._callbacks.hasOwnProperty(id)) {\n        const callbacks = this._callbacks[id];\n        clearTimeout(callbacks.timeout);\n        const errback = callbacks.errback;\n        if (!errback) {\n          continue;\n        }\n        errback({ error: this._createErrorObject(errorCodes.connectionClosed, 'connection closed') });\n      }\n    }\n    this._callbacks = {};\n  }\n\n  private _clearConnectedState() {\n    this._client = null;\n    this._clearServerPingTimeout();\n    this._clearRefreshTimeout();\n\n    // fire events for client-side subscriptions.\n    for (const channel in this._subs) {\n      if (!this._subs.hasOwnProperty(channel)) {\n        continue;\n      }\n      const sub = this._subs[channel];\n      if (sub.state === SubscriptionState.Subscribed) {\n        // @ts-ignore \u2013 we are hiding some symbols from public API autocompletion.\n        sub._setSubscribing(subscribingCodes.transportClosed, 'transport closed');\n      }\n    }\n\n    // fire events for server-side subscriptions.\n    for (const channel in this._serverSubs) {\n      if (this._serverSubs.hasOwnProperty(channel)) {\n        this.emit('subscribing', { channel: channel });\n      }\n    }\n  }\n\n  private _handleWriteError(commands: any[]) {\n    for (const command of commands) {\n      const id = command.id;\n      if (!(id in this._callbacks)) {\n        continue;\n      }\n      const callbacks = this._callbacks[id];\n      clearTimeout(this._callbacks[id].timeout);\n      delete this._callbacks[id];\n      const errback = callbacks.errback;\n      errback({ error: this._createErrorObject(errorCodes.transportWriteError, 'transport write error') });\n    }\n  }\n\n  private _transportSendCommands(commands: any[]) {\n    if (!commands.length) {\n      return true;\n    }\n    if (!this._transport) {\n      return false\n    }\n    try {\n      this._transport.send(this._codec.encodeCommands(commands), this._session, this._node);\n    } catch (e) {\n      this._debug('error writing commands', e);\n      this._handleWriteError(commands);\n      return false;\n    }\n    return true;\n  }\n\n  private _initializeTransport() {\n    let websocket: any;\n    if (this._config.websocket !== null) {\n      websocket = this._config.websocket;\n    } else {\n      if (!(typeof globalThis.WebSocket !== 'function' && typeof globalThis.WebSocket !== 'object')) {\n        websocket = globalThis.WebSocket;\n      }\n    }\n\n    let sockjs = null;\n    if (this._config.sockjs !== null) {\n      sockjs = this._config.sockjs;\n    } else {\n      if (typeof globalThis.SockJS !== 'undefined') {\n        sockjs = globalThis.SockJS;\n      }\n    }\n\n    let eventsource: any = null;\n    if (this._config.eventsource !== null) {\n      eventsource = this._config.eventsource;\n    } else {\n      if (typeof globalThis.EventSource !== 'undefined') {\n        eventsource = globalThis.EventSource;\n      }\n    }\n\n    let fetchFunc: any = null;\n    if (this._config.fetch !== null) {\n      fetchFunc = this._config.fetch;\n    } else {\n      if (typeof globalThis.fetch !== 'undefined') {\n        fetchFunc = globalThis.fetch;\n      }\n    }\n\n    let readableStream: any = null;\n    if (this._config.readableStream !== null) {\n      readableStream = this._config.readableStream;\n    } else {\n      if (typeof globalThis.ReadableStream !== 'undefined') {\n        readableStream = globalThis.ReadableStream;\n      }\n    }\n\n    if (!this._emulation) {\n      if (startsWith(this._endpoint, 'http')) {\n        throw new Error('Provide explicit transport endpoints configuration in case of using HTTP (i.e. using array of TransportEndpoint instead of a single string), or use ws(s):// scheme in an endpoint if you aimed using WebSocket transport');\n      } else {\n        this._debug('client will use websocket');\n        this._transport = new WebsocketTransport(this._endpoint as string, {\n          websocket: websocket\n        });\n        if (!this._transport.supported()) {\n          throw new Error('WebSocket not available');\n        }\n      }\n    } else {\n      if (this._currentTransportIndex >= this._transports.length) {\n        this._triedAllTransports = true;\n        this._currentTransportIndex = 0;\n      }\n      let count = 0;\n      while (true) {\n        if (count >= this._transports.length) {\n          throw new Error('no supported transport found');\n        }\n        const transportConfig = this._transports[this._currentTransportIndex];\n        const transportName = transportConfig.transport;\n        const transportEndpoint = transportConfig.endpoint;\n\n        if (transportName === 'websocket') {\n          this._debug('trying websocket transport');\n          this._transport = new WebsocketTransport(transportEndpoint, {\n            websocket: websocket\n          });\n          if (!this._transport.supported()) {\n            this._debug('websocket transport not available');\n            this._currentTransportIndex++;\n            count++;\n            continue;\n          }\n        } else if (transportName === 'webtransport') {\n          this._debug('trying webtransport transport');\n          this._transport = new WebtransportTransport(transportEndpoint, {\n            webtransport: globalThis.WebTransport,\n            decoder: this._codec,\n            encoder: this._codec\n          });\n          if (!this._transport.supported()) {\n            this._debug('webtransport transport not available');\n            this._currentTransportIndex++;\n            count++;\n            continue;\n          }\n        } else if (transportName === 'http_stream') {\n          this._debug('trying http_stream transport');\n          this._transport = new HttpStreamTransport(transportEndpoint, {\n            fetch: fetchFunc,\n            readableStream: readableStream,\n            emulationEndpoint: this._config.emulationEndpoint,\n            decoder: this._codec,\n            encoder: this._codec\n          });\n          if (!this._transport.supported()) {\n            this._debug('http_stream transport not available');\n            this._currentTransportIndex++;\n            count++;\n            continue;\n          }\n        } else if (transportName === 'sse') {\n          this._debug('trying sse transport');\n          this._transport = new SseTransport(transportEndpoint, {\n            eventsource: eventsource,\n            fetch: fetchFunc,\n            emulationEndpoint: this._config.emulationEndpoint,\n          });\n          if (!this._transport.supported()) {\n            this._debug('sse transport not available');\n            this._currentTransportIndex++;\n            count++;\n            continue;\n          }\n        } else if (transportName === 'sockjs') {\n          this._debug('trying sockjs');\n          this._transport = new SockjsTransport(transportEndpoint, {\n            sockjs: sockjs,\n            sockjsOptions: this._config.sockjsOptions\n          });\n          if (!this._transport.supported()) {\n            this._debug('sockjs transport not available');\n            this._currentTransportIndex++;\n            count++;\n            continue;\n          }\n        } else {\n          throw new Error('unknown transport ' + transportName);\n        }\n        break;\n      }\n    }\n\n    const self = this;\n    const transport = this._transport;\n    const transportId = this._nextTransportId();\n    self._debug(\"id of transport\", transportId);\n    let wasOpen = false;\n\n    let optimistic = true;\n    if (this._transport.name() === 'sse') {\n      // Avoid using optimistic subscriptions with SSE/EventSource as we are sending\n      // initial data in URL params. URL is recommended to be 2048 chars max \u2013 so adding\n      // subscription data may be risky.\n      optimistic = false;\n    }\n\n    const initialCommands: any[] = [];\n\n    if (this._transport.emulation()) {\n      const connectCommand = self._sendConnect(true);\n      initialCommands.push(connectCommand);\n      if (optimistic) {\n        const subscribeCommands: any[] = self._sendSubscribeCommands(true, true);\n        for (const i in subscribeCommands) {\n          if (subscribeCommands.hasOwnProperty(i)) {\n            initialCommands.push(subscribeCommands[i]);\n          }\n        }\n      }\n    }\n\n    this._setNetworkEvents();\n\n    const initialData = this._codec.encodeCommands(initialCommands);\n\n    this._transportClosed = false;\n\n    let connectTimeout: any;\n    connectTimeout = setTimeout(function () {\n      transport.close();\n    }, this._config.timeout);\n\n    this._transport.initialize(this._codec.name(), {\n      onOpen: function () {\n        if (connectTimeout) {\n          clearTimeout(connectTimeout);\n          connectTimeout = null;\n        }\n        if (self._transportId != transportId) {\n          self._debug('open callback from non-actual transport');\n          transport.close();\n          return;\n        }\n        wasOpen = true;\n        self._debug(transport.subName(), 'transport open');\n        self._transportWasOpen = true;\n        if (transport.emulation()) {\n          return;\n        }\n        self.startBatching();\n        self._sendConnect(false);\n        if (optimistic) {\n          self._sendSubscribeCommands(true, false);\n        }\n        self.stopBatching();\n      },\n      onError: function (e: any) {\n        if (self._transportId != transportId) {\n          self._debug('error callback from non-actual transport');\n          return;\n        }\n        self._debug('transport level error', e);\n      },\n      onClose: function (closeEvent) {\n        if (connectTimeout) {\n          clearTimeout(connectTimeout);\n          connectTimeout = null;\n        }\n        if (self._transportId != transportId) {\n          self._debug('close callback from non-actual transport');\n          return;\n        }\n        self._debug(transport.subName(), 'transport closed');\n        self._transportClosed = true;\n\n        let reason = 'connection closed';\n        let needReconnect = true;\n        let code = 0;\n\n        if (closeEvent && 'code' in closeEvent && closeEvent.code) {\n          code = closeEvent.code;\n        }\n\n        if (closeEvent && closeEvent.reason) {\n          try {\n            const advice = JSON.parse(closeEvent.reason);\n            reason = advice.reason;\n            needReconnect = advice.reconnect;\n          } catch (e) {\n            reason = closeEvent.reason;\n            if ((code >= 3500 && code < 4000) || (code >= 4500 && code < 5000)) {\n              needReconnect = false;\n            }\n          }\n        }\n\n        if (code < 3000) {\n          if (code === 1009) {\n            code = disconnectedCodes.messageSizeLimit;\n            reason = 'message size limit exceeded';\n            needReconnect = false;\n          } else {\n            code = connectingCodes.transportClosed;\n            reason = 'transport closed';\n          }\n          if (self._emulation && !self._transportWasOpen) {\n            self._currentTransportIndex++;\n            if (self._currentTransportIndex >= self._transports.length) {\n              self._triedAllTransports = true;\n              self._currentTransportIndex = 0;\n            }\n          }\n        } else {\n          // Codes >= 3000 are sent from a server application level.\n          self._transportWasOpen = true;\n        }\n\n        if (self._isConnecting() && !wasOpen) {\n          self.emit('error', {\n            type: 'transport',\n            error: {\n              code: errorCodes.transportClosed,\n              message: 'transport closed'\n            },\n            transport: transport.name()\n          });\n        }\n\n        self._reconnecting = false;\n        self._disconnect(code, reason, needReconnect);\n      },\n      onMessage: function (data) {\n        self._dataReceived(data);\n      }\n    }, initialData);\n  }\n\n  private _sendConnect(skipSending: boolean): any {\n    const connectCommand = this._constructConnectCommand();\n    const self = this;\n    this._call(connectCommand, skipSending).then(resolveCtx => {\n      // @ts-ignore = improve later.\n      const result = resolveCtx.reply.connect;\n      self._connectResponse(result);\n      // @ts-ignore - improve later.\n      if (resolveCtx.next) {\n        // @ts-ignore - improve later.\n        resolveCtx.next();\n      }\n    }, rejectCtx => {\n      self._connectError(rejectCtx.error);\n      if (rejectCtx.next) {\n        rejectCtx.next();\n      }\n    });\n    return connectCommand;\n  }\n\n  private _startReconnecting() {\n    this._debug('start reconnecting');\n    if (!this._isConnecting()) {\n      this._debug('stop reconnecting: client not in connecting state');\n      return;\n    }\n    if (this._reconnecting) {\n      this._debug('reconnect already in progress, return from reconnect routine');\n      return;\n    }\n    if (this._transportClosed === false) {\n      this._debug('waiting for transport close');\n      return;\n    }\n\n    this._reconnecting = true;\n    const self = this;\n    const emptyToken = this._token === '';\n    const needTokenRefresh = this._refreshRequired || (emptyToken && this._config.getToken !== null);\n    if (!needTokenRefresh) {\n      if (this._config.getData) {\n        this._config.getData().then(function (data: any) {\n          if (!self._isConnecting()) {\n            return;\n          }\n          self._data = data;\n          self._initializeTransport();\n        })\n      } else {\n        this._initializeTransport();\n      }\n      return;\n    }\n\n    this._getToken().then(function (token: string) {\n      if (!self._isConnecting()) {\n        return;\n      }\n      if (token == null || token == undefined) {\n        self._failUnauthorized();\n        return;\n      }\n      self._token = token;\n      self._debug('connection token refreshed');\n      if (self._config.getData) {\n        self._config.getData().then(function (data: any) {\n          if (!self._isConnecting()) {\n            return;\n          }\n          self._data = data;\n          self._initializeTransport();\n        })\n      } else {\n        self._initializeTransport();\n      }\n    }).catch(function (e) {\n      if (!self._isConnecting()) {\n        return;\n      }\n      if (e instanceof UnauthorizedError) {\n        self._failUnauthorized();\n        return;\n      }\n      self.emit('error', {\n        'type': 'connectToken',\n        'error': {\n          code: errorCodes.clientConnectToken,\n          message: e !== undefined ? e.toString() : ''\n        }\n      });\n      const delay = self._getReconnectDelay();\n      self._debug('error on connection token refresh, reconnect after ' + delay + ' milliseconds', e);\n      self._reconnecting = false;\n      self._reconnectTimeout = setTimeout(() => {\n        self._startReconnecting();\n      }, delay);\n    });\n  }\n\n  private _connectError(err: any) {\n    if (this.state !== State.Connecting) {\n      return;\n    }\n    if (err.code === 109) { // token expired.\n      // next connect attempt will try to refresh token.\n      this._refreshRequired = true;\n    }\n    if (err.code < 100 || err.temporary === true || err.code === 109) {\n      this.emit('error', {\n        'type': 'connect',\n        'error': err\n      });\n      this._debug('closing transport due to connect error');\n      this._reconnecting = false;\n      this._disconnect(err.code, err.message, true);\n    } else {\n      this._disconnect(err.code, err.message, false);\n    }\n  }\n\n  private _scheduleReconnect() {\n    if (!this._isConnecting()) {\n      return;\n    }\n    let isInitialHandshake = false;\n    if (this._emulation && !this._transportWasOpen && !this._triedAllTransports) {\n      isInitialHandshake = true;\n    }\n    let delay = this._getReconnectDelay();\n    if (isInitialHandshake) {\n      delay = 0;\n    }\n    this._debug('reconnect after ' + delay + ' milliseconds');\n    this._reconnectTimeout = setTimeout(() => {\n      this._startReconnecting();\n    }, delay);\n  }\n\n  private _constructConnectCommand(): any {\n    const req: any = {};\n\n    if (this._token) {\n      req.token = this._token;\n    }\n    if (this._data) {\n      req.data = this._data;\n    }\n    if (this._config.name) {\n      req.name = this._config.name;\n    }\n    if (this._config.version) {\n      req.version = this._config.version;\n    }\n\n    const subs = {};\n    let hasSubs = false;\n    for (const channel in this._serverSubs) {\n      if (this._serverSubs.hasOwnProperty(channel) && this._serverSubs[channel].recoverable) {\n        hasSubs = true;\n        const sub = {\n          'recover': true\n        };\n        if (this._serverSubs[channel].offset) {\n          sub['offset'] = this._serverSubs[channel].offset;\n        }\n        if (this._serverSubs[channel].epoch) {\n          sub['epoch'] = this._serverSubs[channel].epoch;\n        }\n        subs[channel] = sub;\n      }\n    }\n    if (hasSubs) {\n      req.subs = subs;\n    }\n    return {\n      connect: req\n    };\n  }\n\n  private _getHistoryRequest(channel: string, options?: HistoryOptions) {\n    const req: any = {\n      channel: channel\n    };\n    if (options !== undefined) {\n      if (options.since) {\n        req.since = {\n          offset: options.since.offset\n        };\n        if (options.since.epoch) {\n          req.since.epoch = options.since.epoch;\n        }\n      }\n      if (options.limit !== undefined) {\n        req.limit = options.limit;\n      }\n      if (options.reverse === true) {\n        req.reverse = true;\n      }\n    }\n    return req;\n  }\n\n  private _methodCall(): any {\n    if (this._isConnected()) {\n      return Promise.resolve();\n    }\n    return new Promise((res, rej) => {\n      const timeout = setTimeout(function () {\n        rej({ code: errorCodes.timeout, message: 'timeout' });\n      }, this._config.timeout);\n      this._promises[this._nextPromiseId()] = {\n        timeout: timeout,\n        resolve: res,\n        reject: rej\n      };\n    });\n  }\n\n  private _callPromise(cmd: any, resultCB: any): any {\n    return new Promise((resolve, reject) => {\n      this._call(cmd, false).then(resolveCtx => {\n        // @ts-ignore - improve later.\n        resolve(resultCB(resolveCtx.reply));\n        // @ts-ignore - improve later.\n        if (resolveCtx.next) {\n          // @ts-ignore - improve later.\n          resolveCtx.next();\n        }\n      }, rejectCtx => {\n        reject(rejectCtx.error);\n        if (rejectCtx.next) {\n          rejectCtx.next();\n        }\n      });\n    });\n  }\n\n  private _dataReceived(data) {\n    if (this._serverPing > 0) {\n      this._waitServerPing();\n    }\n    const replies = this._codec.decodeReplies(data);\n    // We have to guarantee order of events in replies processing - i.e. start processing\n    // next reply only when we finished processing of current one. Without syncing things in\n    // this way we could get wrong publication events order as reply promises resolve\n    // on next loop tick so for loop continues before we finished emitting all reply events.\n    this._dispatchPromise = this._dispatchPromise.then(() => {\n      let finishDispatch;\n      this._dispatchPromise = new Promise(resolve => {\n        finishDispatch = resolve;\n      });\n      this._dispatchSynchronized(replies, finishDispatch);\n    });\n  }\n\n  private _dispatchSynchronized(replies: any[], finishDispatch: any) {\n    let p: Promise<unknown> = Promise.resolve();\n    for (const i in replies) {\n      if (replies.hasOwnProperty(i)) {\n        p = p.then(() => {\n          return this._dispatchReply(replies[i]);\n        });\n      }\n    }\n    p = p.then(() => {\n      finishDispatch();\n    });\n  }\n\n  private _dispatchReply(reply: any) {\n    let next: any;\n    const p = new Promise(resolve => {\n      next = resolve;\n    });\n\n    if (reply === undefined || reply === null) {\n      this._debug('dispatch: got undefined or null reply');\n      next();\n      return p;\n    }\n\n    const id = reply.id;\n\n    if (id && id > 0) {\n      this._handleReply(reply, next);\n    } else {\n      if (!reply.push) {\n        this._handleServerPing(next);\n      } else {\n        this._handlePush(reply.push, next);\n      }\n    }\n\n    return p;\n  }\n\n  private _call(cmd: any, skipSending: boolean) {\n    return new Promise((resolve, reject) => {\n      cmd.id = this._nextCommandId();\n      this._registerCall(cmd.id, resolve, reject);\n      if (!skipSending) {\n        this._addCommand(cmd);\n      }\n    });\n  }\n\n  private _startConnecting() {\n    this._debug('start connecting');\n    if (this._setState(State.Connecting)) {\n      this.emit('connecting', { code: connectingCodes.connectCalled, reason: 'connect called' });\n    }\n    this._client = null;\n    this._startReconnecting();\n  }\n\n  private _disconnect(code: number, reason: string, reconnect: boolean) {\n    if (this._isDisconnected()) {\n      return;\n    }\n\n    const previousState = this.state;\n\n    const ctx = {\n      code: code,\n      reason: reason\n    };\n\n    let needEvent = false;\n\n    if (reconnect) {\n      needEvent = this._setState(State.Connecting);\n    } else {\n      needEvent = this._setState(State.Disconnected);\n      this._rejectPromises({ code: errorCodes.clientDisconnected, message: 'disconnected' });\n    }\n\n    this._clearOutgoingRequests();\n\n    if (previousState === State.Connecting) {\n      this._clearReconnectTimeout();\n    }\n    if (previousState === State.Connected) {\n      this._clearConnectedState();\n    }\n\n    if (needEvent) {\n      if (this._isConnecting()) {\n        this.emit('connecting', ctx);\n      } else {\n        this.emit('disconnected', ctx);\n      }\n    }\n\n    if (this._transport) {\n      this._debug(\"closing existing transport\");\n      const transport = this._transport;\n      this._transport = null;\n      transport.close(); // Close only after setting this._transport to null to avoid recursion when calling transport close().\n      this._transportClosed = true;\n      this._nextTransportId();\n    } else {\n      this._debug(\"no transport to close\");\n    }\n    this._scheduleReconnect();\n  }\n\n  private _failUnauthorized() {\n    this._disconnect(disconnectedCodes.unauthorized, 'unauthorized', false);\n  }\n\n  private _getToken(): Promise<string> {\n    this._debug('get connection token');\n    if (!this._config.getToken) {\n      this.emit('error', {\n        type: 'configuration',\n        error: {\n          code: errorCodes.badConfiguration,\n          message: 'token expired but no getToken function set in the configuration'\n        }\n      });\n      throw new UnauthorizedError('');\n    }\n    return this._config.getToken({});\n  }\n\n  private _refresh() {\n    const clientId = this._client;\n    const self = this;\n    this._getToken().then(function (token) {\n      if (clientId !== self._client) {\n        return;\n      }\n      if (!token) {\n        self._failUnauthorized();\n        return;\n      }\n      self._token = token;\n      self._debug('connection token refreshed');\n\n      if (!self._isConnected()) {\n        return;\n      }\n\n      const cmd = {\n        refresh: { token: self._token }\n      };\n\n      self._call(cmd, false).then(resolveCtx => {\n        // @ts-ignore - improve later.\n        const result = resolveCtx.reply.refresh;\n        self._refreshResponse(result);\n        // @ts-ignore - improve later.\n        if (resolveCtx.next) {\n          // @ts-ignore - improve later.\n          resolveCtx.next();\n        }\n      }, rejectCtx => {\n        self._refreshError(rejectCtx.error);\n        if (rejectCtx.next) {\n          rejectCtx.next();\n        }\n      });\n    }).catch(function (e) {\n      if (!self._isConnected()) {\n        return;\n      }\n      if (e instanceof UnauthorizedError) {\n        self._failUnauthorized();\n        return;\n      }\n      self.emit('error', {\n        type: 'refreshToken',\n        error: {\n          code: errorCodes.clientRefreshToken,\n          message: e !== undefined ? e.toString() : ''\n        }\n      });\n      self._refreshTimeout = setTimeout(() => self._refresh(), self._getRefreshRetryDelay());\n    });\n  }\n\n  private _refreshError(err: any) {\n    if (err.code < 100 || err.temporary === true) {\n      this.emit('error', {\n        type: 'refresh',\n        error: err\n      });\n      this._refreshTimeout = setTimeout(() => this._refresh(), this._getRefreshRetryDelay());\n    } else {\n      this._disconnect(err.code, err.message, false);\n    }\n  }\n\n  private _getRefreshRetryDelay() {\n    return backoff(0, 5000, 10000);\n  }\n\n  private _refreshResponse(result: any) {\n    if (this._refreshTimeout) {\n      clearTimeout(this._refreshTimeout);\n      this._refreshTimeout = null;\n    }\n    if (result.expires) {\n      this._client = result.client;\n      this._refreshTimeout = setTimeout(() => this._refresh(), ttlMilliseconds(result.ttl));\n    }\n  }\n\n  private _removeSubscription(sub: Subscription | null) {\n    if (sub === null) {\n      return;\n    }\n    delete this._subs[sub.channel];\n  }\n\n  protected _unsubscribe(sub: Subscription) {\n    if (!this._isConnected()) {\n      return;\n    }\n    const req = {\n      channel: sub.channel\n    };\n    const cmd = { unsubscribe: req };\n\n    const self = this;\n\n    this._call(cmd, false).then(resolveCtx => {\n      // @ts-ignore - improve later.\n      if (resolveCtx.next) {\n        // @ts-ignore - improve later.\n        resolveCtx.next();\n      }\n    }, rejectCtx => {\n      if (rejectCtx.next) {\n        rejectCtx.next();\n      }\n      self._disconnect(connectingCodes.unsubscribeError, 'unsubscribe error', true);\n    });\n  }\n\n  private _getSub(channel: string) {\n    const sub = this._subs[channel];\n    if (!sub) {\n      return null;\n    }\n    return sub;\n  }\n\n  private _isServerSub(channel: string) {\n    return this._serverSubs[channel] !== undefined;\n  }\n\n  private _sendSubscribeCommands(optimistic: boolean, skipSending: boolean): any[] {\n    const commands: any[] = [];\n    for (const channel in this._subs) {\n      if (!this._subs.hasOwnProperty(channel)) {\n        continue;\n      }\n      const sub = this._subs[channel];\n      // @ts-ignore \u2013 we are hiding some symbols from public API autocompletion.\n      if (sub._inflight === true) {\n        continue;\n      }\n      if (sub.state === SubscriptionState.Subscribing) {\n        // @ts-ignore \u2013 we are hiding some symbols from public API autocompletion.\n        const cmd = sub._subscribe(optimistic, skipSending);\n        if (cmd) {\n          commands.push(cmd);\n        }\n      }\n    }\n    return commands;\n  }\n\n  private _connectResponse(result: any) {\n    this._transportWasOpen = true;\n    this._reconnectAttempts = 0;\n    this._refreshRequired = false;\n\n    if (this._isConnected()) {\n      return;\n    }\n\n    this._client = result.client;\n    this._setState(State.Connected);\n\n    if (this._refreshTimeout) {\n      clearTimeout(this._refreshTimeout);\n    }\n    if (result.expires) {\n      this._refreshTimeout = setTimeout(() => this._refresh(), ttlMilliseconds(result.ttl));\n    }\n\n    this._session = result.session;\n    this._node = result.node;\n\n    this.startBatching();\n    this._sendSubscribeCommands(false, false);\n    this.stopBatching();\n\n    const ctx: any = {\n      client: result.client,\n      transport: this._transport.subName()\n    };\n    if (result.data) {\n      ctx.data = result.data;\n    }\n\n    this.emit('connected', ctx);\n\n    this._resolvePromises();\n\n    this._processServerSubs(result.subs || {});\n\n    if (result.ping && result.ping > 0) {\n      this._serverPing = result.ping * 1000;\n      this._sendPong = result.pong === true;\n      this._waitServerPing();\n    } else {\n      this._serverPing = 0;\n    }\n  }\n\n  private _processServerSubs(subs: Record<string, any>) {\n    for (const channel in subs) {\n      if (!subs.hasOwnProperty(channel)) {\n        continue;\n      }\n      const sub = subs[channel];\n      this._serverSubs[channel] = {\n        'offset': sub.offset,\n        'epoch': sub.epoch,\n        'recoverable': sub.recoverable || false\n      };\n      const subCtx = this._getSubscribeContext(channel, sub);\n      this.emit('subscribed', subCtx);\n    }\n\n    for (const channel in subs) {\n      if (!subs.hasOwnProperty(channel)) {\n        continue;\n      }\n      const sub = subs[channel];\n      if (sub.recovered) {\n        const pubs = sub.publications;\n        if (pubs && pubs.length > 0) {\n          for (const i in pubs) {\n            if (pubs.hasOwnProperty(i)) {\n              this._handlePublication(channel, pubs[i]);\n            }\n          }\n        }\n      }\n    }\n\n    for (const channel in this._serverSubs) {\n      if (!this._serverSubs.hasOwnProperty(channel)) {\n        continue;\n      }\n      if (!subs[channel]) {\n        this.emit('unsubscribed', { channel: channel });\n        delete this._serverSubs[channel];\n      }\n    }\n  }\n\n  private _clearRefreshTimeout() {\n    if (this._refreshTimeout !== null) {\n      clearTimeout(this._refreshTimeout);\n      this._refreshTimeout = null;\n    }\n  }\n\n  private _clearReconnectTimeout() {\n    if (this._reconnectTimeout !== null) {\n      clearTimeout(this._reconnectTimeout);\n      this._reconnectTimeout = null;\n    }\n  }\n\n  private _clearServerPingTimeout() {\n    if (this._serverPingTimeout !== null) {\n      clearTimeout(this._serverPingTimeout);\n      this._serverPingTimeout = null;\n    }\n  }\n\n  private _waitServerPing() {\n    if (this._config.maxServerPingDelay === 0) {\n      return;\n    }\n    if (!this._isConnected()) {\n      return;\n    }\n    this._clearServerPingTimeout();\n    this._serverPingTimeout = setTimeout(() => {\n      if (!this._isConnected()) {\n        return;\n      }\n      this._disconnect(connectingCodes.noPing, 'no ping', true);\n    }, this._serverPing + this._config.maxServerPingDelay);\n  }\n\n  private _getSubscribeContext(channel: string, result: any): SubscribedContext {\n    const ctx: any = {\n      channel: channel,\n      positioned: false,\n      recoverable: false,\n      wasRecovering: false,\n      recovered: false\n    };\n    if (result.recovered) {\n      ctx.recovered = true;\n    }\n    if (result.positioned) {\n      ctx.positioned = true;\n    }\n    if (result.recoverable) {\n      ctx.recoverable = true;\n    }\n    if (result.was_recovering) {\n      ctx.wasRecovering = true;\n    }\n    let epoch = '';\n    if ('epoch' in result) {\n      epoch = result.epoch;\n    }\n    let offset = 0;\n    if ('offset' in result) {\n      offset = result.offset;\n    }\n    if (ctx.positioned || ctx.recoverable) {\n      ctx.streamPosition = {\n        'offset': offset,\n        'epoch': epoch\n      };\n    }\n    if (result.data) {\n      ctx.data = result.data;\n    }\n    return ctx;\n  }\n\n  private _handleReply(reply: any, next: any) {\n    const id = reply.id;\n    if (!(id in this._callbacks)) {\n      next();\n      return;\n    }\n    const callbacks = this._callbacks[id];\n    clearTimeout(this._callbacks[id].timeout);\n    delete this._callbacks[id];\n\n    if (!errorExists(reply)) {\n      const callback = callbacks.callback;\n      if (!callback) {\n        return;\n      }\n      callback({ reply, next });\n    } else {\n      const errback = callbacks.errback;\n      if (!errback) {\n        next();\n        return;\n      }\n      const error = reply.error;\n      errback({ error, next });\n    }\n  }\n\n  private _handleJoin(channel: string, join: any) {\n    const sub = this._getSub(channel);\n    if (!sub) {\n      if (this._isServerSub(channel)) {\n        const ctx = { channel: channel, info: this._getJoinLeaveContext(join.info) };\n        this.emit('join', ctx);\n      }\n      return;\n    }\n    // @ts-ignore \u2013 we are hiding some symbols from public API autocompletion.\n    sub._handleJoin(join);\n  }\n\n  private _handleLeave(channel: string, leave: any) {\n    const sub = this._getSub(channel);\n    if (!sub) {\n      if (this._isServerSub(channel)) {\n        const ctx = { channel: channel, info: this._getJoinLeaveContext(leave.info) };\n        this.emit('leave', ctx);\n      }\n      return;\n    }\n    // @ts-ignore \u2013 we are hiding some symbols from public API autocompletion.\n    sub._handleLeave(leave);\n  }\n\n  private _handleUnsubscribe(channel: string, unsubscribe: any) {\n    const sub = this._getSub(channel);\n    if (!sub) {\n      if (this._isServerSub(channel)) {\n        delete this._serverSubs[channel];\n        this.emit('unsubscribed', { channel: channel });\n      }\n      return;\n    }\n    if (unsubscribe.code < 2500) {\n      // @ts-ignore \u2013 we are hiding some symbols from public API autocompletion.\n      sub._setUnsubscribed(unsubscribe.code, unsubscribe.reason, false);\n    } else {\n      // @ts-ignore \u2013 we are hiding some symbols from public API autocompletion.\n      sub._setSubscribing(unsubscribe.code, unsubscribe.reason);\n    }\n  }\n\n  private _handleSubscribe(channel: string, sub: any) {\n    this._serverSubs[channel] = {\n      'offset': sub.offset,\n      'epoch': sub.epoch,\n      'recoverable': sub.recoverable || false\n    };\n    this.emit('subscribed', this._getSubscribeContext(channel, sub));\n  }\n\n  private _handleDisconnect(disconnect: any) {\n    const code = disconnect.code;\n    let reconnect = true;\n    if ((code >= 3500 && code < 4000) || (code >= 4500 && code < 5000)) {\n      reconnect = false;\n    }\n    this._disconnect(code, disconnect.reason, reconnect);\n  }\n\n  private _getPublicationContext(channel: string, pub: any) {\n    const ctx: any = {\n      channel: channel,\n      data: pub.data\n    };\n    if (pub.offset) {\n      ctx.offset = pub.offset;\n    }\n    if (pub.info) {\n      ctx.info = this._getJoinLeaveContext(pub.info);\n    }\n    if (pub.tags) {\n      ctx.tags = pub.tags;\n    }\n    return ctx;\n  }\n\n  private _getJoinLeaveContext(clientInfo: any) {\n    const info: any = {\n      client: clientInfo.client,\n      user: clientInfo.user\n    };\n    if (clientInfo.conn_info) {\n      info.connInfo = clientInfo.conn_info;\n    }\n    if (clientInfo.chan_info) {\n      info.chanInfo = clientInfo.chan_info;\n    }\n    return info;\n  }\n\n  private _handlePublication(channel: string, pub: any) {\n    const sub = this._getSub(channel);\n    if (!sub) {\n      if (this._isServerSub(channel)) {\n        const ctx = this._getPublicationContext(channel, pub);\n        this.emit('publication', ctx);\n        if (pub.offset !== undefined) {\n          this._serverSubs[channel].offset = pub.offset;\n        }\n      }\n      return;\n    }\n    // @ts-ignore \u2013 we are hiding some symbols from public API autocompletion.\n    sub._handlePublication(pub);\n  }\n\n  private _handleMessage(message: any) {\n    this.emit('message', { data: message.data });\n  }\n\n  private _handleServerPing(next: any) {\n    if (this._sendPong) {\n      const cmd = {};\n      this._transportSendCommands([cmd]);\n    }\n    next();\n  }\n\n  private _handlePush(data: any, next: any) {\n    const channel = data.channel;\n    if (data.pub) {\n      this._handlePublication(channel, data.pub);\n    } else if (data.message) {\n      this._handleMessage(data.message);\n    } else if (data.join) {\n      this._handleJoin(channel, data.join);\n    } else if (data.leave) {\n      this._handleLeave(channel, data.leave);\n    } else if (data.unsubscribe) {\n      this._handleUnsubscribe(channel, data.unsubscribe);\n    } else if (data.subscribe) {\n      this._handleSubscribe(channel, data.subscribe);\n    } else if (data.disconnect) {\n      this._handleDisconnect(data.disconnect);\n    }\n    next();\n  }\n\n  private _flush() {\n    const commands = this._commands.slice(0);\n    this._commands = [];\n    this._transportSendCommands(commands);\n  }\n\n  private _createErrorObject(code: number, message: string, temporary?: boolean) {\n    const errObject: any = {\n      code: code,\n      message: message\n    };\n    if (temporary) {\n      errObject.temporary = true;\n    }\n    return errObject;\n  }\n\n  private _registerCall(id: number, callback: any, errback: any) {\n    this._callbacks[id] = {\n      callback: callback,\n      errback: errback,\n      timeout: null\n    };\n    this._callbacks[id].timeout = setTimeout(() => {\n      delete this._callbacks[id];\n      if (isFunction(errback)) {\n        errback({ error: this._createErrorObject(errorCodes.timeout, 'timeout') });\n      }\n    }, this._config.timeout);\n  }\n\n  private _addCommand(command: any) {\n    if (this._batching) {\n      this._commands.push(command);\n    } else {\n      this._transportSendCommands([command]);\n    }\n  }\n\n  private _nextPromiseId() {\n    return ++this._promiseId;\n  }\n\n  private _nextTransportId() {\n    return ++this._transportId;\n  }\n\n  private _resolvePromises() {\n    for (const id in this._promises) {\n      if (!this._promises.hasOwnProperty(id)) {\n        continue;\n      }\n      if (this._promises[id].timeout) {\n        clearTimeout(this._promises[id].timeout);\n      }\n      this._promises[id].resolve();\n      delete this._promises[id];\n    }\n  }\n\n  private _rejectPromises(err: any) {\n    for (const id in this._promises) {\n      if (!this._promises.hasOwnProperty(id)) {\n        continue;\n      }\n      if (this._promises[id].timeout) {\n        clearTimeout(this._promises[id].timeout);\n      }\n      this._promises[id].reject(err);\n      delete this._promises[id];\n    }\n  }\n}\n\nCentrifuge.SubscriptionState = SubscriptionState;\nCentrifuge.State = State\nCentrifuge.UnauthorizedError = UnauthorizedError;\n", "/**\n * This file is the entrypoint of browser builds.\n */\nimport { Centrifuge } from './centrifuge'\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n(window as any).Centrifuge = Centrifuge\n"],
  "mappings": "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",
  "names": ["require_events", "__commonJSMin", "exports", "module", "R", "ReflectApply", "target", "receiver", "args", "ReflectOwnKeys", "ProcessEmitWarning", "warning", "NumberIsNaN", "value", "EventEmitter", "once", "defaultMaxListeners", "checkListener", "listener", "arg", "n", "_getMaxListeners", "that", "type", "i", "doError", "events", "er", "err", "handler", "len", "listeners", "arrayClone", "_addListener", "prepend", "m", "existing", "w", "onceWrapper", "_onceWrap", "state", "wrapped", "list", "position", "originalListener", "spliceOne", "keys", "key", "_listeners", "unwrap", "evlistener", "unwrapListeners", "emitter", "listenerCount", "arr", "copy", "index", "ret", "name", "resolve", "reject", "errorListener", "resolver", "eventTargetAgnosticAddListener", "addErrorHandlerIfEventEmitter", "flags", "wrapListener", "import_events", "State", "SubscriptionState", "startsWith", "value", "prefix", "isFunction", "log", "level", "args", "logger", "randomInt", "min", "max", "backoff", "step", "interval", "errorExists", "data", "ttlMilliseconds", "ttl", "Subscription", "EventEmitter", "centrifuge", "channel", "options", "ctx", "timeout", "res", "rej", "data", "self", "opts", "newState", "oldState", "result", "pubs", "ttlMilliseconds", "code", "reason", "optimistic", "skipSending", "getDataCtx", "token", "e", "UnauthorizedError", "req", "offset", "epoch", "cmd", "resolveCtx", "rejectCtx", "error", "sendUnsubscribe", "pub", "join", "info", "leave", "id", "err", "delay", "errContext", "backoff", "getToken", "msg", "SockjsTransport", "endpoint", "options", "_protocol", "callbacks", "e", "closeEvent", "event", "data", "WebsocketTransport", "endpoint", "options", "protocol", "callbacks", "subProtocol", "e", "closeEvent", "event", "data", "HttpStreamTransport", "endpoint", "options", "response", "self", "eventTarget", "fetchFunc", "jsonStreamBuf", "jsonStreamPos", "protoStreamBuf", "reader", "controller", "pump", "done", "value", "line", "mergedArray", "result", "data", "error", "e", "protocol", "callbacks", "initialData", "headers", "body", "fetchOptions", "session", "node", "req", "SseTransport", "endpoint", "options", "_protocol", "callbacks", "initialData", "url", "eventsourceOptions", "eventSource", "self", "e", "data", "session", "node", "req", "headers", "body", "fetchFunc", "fetchOptions", "WebtransportTransport", "endpoint", "options", "protocol", "callbacks", "url", "eventTarget", "stream", "e", "reader", "jsonStreamBuf", "jsonStreamPos", "protoStreamBuf", "done", "value", "line", "mergedArray", "result", "data", "binary", "JsonCodec", "commands", "c", "data", "r", "import_events", "defaults", "UnauthorizedError", "message", "Centrifuge", "EventEmitter", "endpoint", "options", "JsonCodec", "ctx", "channel", "sub", "Subscription", "timeout", "res", "rej", "token", "data", "cmd", "self", "method", "reply", "result", "publications", "i", "clients", "clientId", "connInfo", "chanInfo", "args", "log", "transportConfig", "transportName", "newState", "oldState", "eventTarget", "delay", "backoff", "id", "callbacks", "errback", "commands", "command", "e", "websocket", "sockjs", "eventsource", "fetchFunc", "readableStream", "count", "transportEndpoint", "WebsocketTransport", "WebtransportTransport", "HttpStreamTransport", "SseTransport", "SockjsTransport", "startsWith", "transport", "transportId", "wasOpen", "optimistic", "initialCommands", "connectCommand", "subscribeCommands", "initialData", "connectTimeout", "closeEvent", "reason", "needReconnect", "code", "advice", "skipSending", "resolveCtx", "rejectCtx", "emptyToken", "err", "isInitialHandshake", "req", "subs", "hasSubs", "resultCB", "resolve", "reject", "replies", "finishDispatch", "p", "next", "reconnect", "previousState", "needEvent", "ttlMilliseconds", "subCtx", "pubs", "epoch", "offset", "errorExists", "error", "callback", "join", "leave", "unsubscribe", "disconnect", "pub", "clientInfo", "info", "temporary", "errObject", "isFunction", "SubscriptionState", "State", "Centrifuge"]
}
